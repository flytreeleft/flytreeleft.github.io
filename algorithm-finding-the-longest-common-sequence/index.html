<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="算法分析：求解最长公共子序列"><meta name="keywords" content="动态规划,最长公共子序列"><meta name="author" content="flytreeleft,flytreeleft@126.com"><meta name="copyright" content="flytreeleft"><title>算法分析：求解最长公共子序列 | flytreeleft's Blog</title><link rel="shortcut icon" href="/assets/profile/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题描述"><span class="toc-number">1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解方案"><span class="toc-number">2.</span> <span class="toc-text">求解方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划法"><span class="toc-number">2.1.</span> <span class="toc-text">动态规划法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">3.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number">4.</span> <span class="toc-text">附录</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/assets/profile/avatar.jpg"></div><div class="author-info__name text-center">flytreeleft</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://coolshell.cn/" target="_blank">酷壳</a><a class="author-info-links__name text-center" href="https://www.infoq.com/" target="_blank">InfoQ</a><a class="author-info-links__name text-center" href="http://www.yinwang.org/" target="_blank">当然我在扯淡</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/assets/profile/walle-watch-the-stars-sky.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">flytreeleft's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/quotes">Quotes</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">算法分析：求解最长公共子序列</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-06</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法分析/">算法分析</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2,831</span><span class="post-meta__separator">|</span><span>阅读时长: 11 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>算法分析系列文章中的代码可被任何人无偿使用于任何场景且无需注明来源也不必在使用前征得本文作者同意。</p>
<p>算法分析系列文章旨在传播准确、完整、简洁、易懂、规范的代码实现，并传授基本的编程思想和良好的编码习惯与技巧。</p>
<p>若文章中的代码存在问题或逻辑错误，请通过邮件等形式（见文章结尾）告知于本文作者以便及时修正错误或改进代码。</p>
<p>算法系列文章不可避免地会参考和学习众多网友的成果，在行文风格、内容及求解思路上也会进行借鉴，如有侵权嫌疑，请联系本文作者。</p>
<p>PS：若为转载该文章，请务必注明来源，本站点欢迎大家转载。</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如果序列 <script type="math/tex">S_1</script> 中的所有元素按照其在 <script type="math/tex">S_1</script> 中的出现顺序依次出现在另一个序列 <script type="math/tex">S_2</script> 中，则称 <script type="math/tex">S_1</script> 为 <script type="math/tex">S_2</script> 的<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">子序列</a>。</p>
<blockquote>
<p>子序列不要求位置的连续性（即，元素相邻），只要相对顺序不变即可。</p>
</blockquote>
<p>若给定一个序列集合（数量大于或等于2，但通常为两个序列），则这些序列所共同拥有的子序列，称为<strong>公共子序列</strong>。而在这些公共子序列中长度最长的子序列则称为该序列集合的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">最长公共子序列</a>（Longest Common Sequence, LCS）。</p>
<p>本例所要求的便是求解任意两个序列的最长公共子序列（可能存在多个不同的序列），并打印其长度及其其中的任意一个序列。<br><a id="more"></a></p>
<p>例如，序列 <script type="math/tex">\{ B, D, C, A, B, A \}</script> 和 <script type="math/tex">\{ A, B, C, B, D, A, B \}</script> 的最长公共子序列为 <script type="math/tex">\{ B, C, B, A \}</script> 和 <script type="math/tex">\{ B, D, A, B \}</script> ，且其最长公共子序列的长度为<code>4</code>。</p>
<h2 id="求解方案"><a href="#求解方案" class="headerlink" title="求解方案"></a>求解方案</h2><h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><p>首先，对最长公共子序列的求解过程做如下数学推导。</p>
<p>假设，存在序列集合 <script type="math/tex">X_i=\{ x_1, x_2, ..., x_i \}</script> 和 <script type="math/tex">Y_j=\{ y_1, y_2, ..., y_j \}</script> ，其最长公共子序列为 <script type="math/tex">Z_k=\{ z_1, z_2, ..., z_k \}</script> 。则存在以下情况：</p>
<ul>
<li>若 <script type="math/tex">x_i=y_j</script> ，则有 <script type="math/tex">z_k=x_i=y_j</script> ，且 <script type="math/tex">Z_{k-1}=\{ z_1, z_2, ..., z_{k-1} \}</script> 是 <script type="math/tex">X_{i-1}=\{ x_1, x_2, ..., x_{i-1} \}</script> 与 <script type="math/tex">Y_{j-1}=\{ y_1, y_2, ..., y_{j-1} \}</script> 的一个最长公共子序列</li>
<li>若 <script type="math/tex">x_i \neq y_j</script> ，则若 <script type="math/tex">z_k \neq x_i</script> ，那么， <script type="math/tex">Z_k</script> 是 <script type="math/tex">X_{i-1}</script> 与 <script type="math/tex">Y_j</script> 的一个最长公共子序列。注：此时 <script type="math/tex">z_k</script> 不一定等于 <script type="math/tex">y_j</script> ，但该推论是包含等于或不等于的情况的</li>
<li>若 <script type="math/tex">x_i \neq y_j</script> ，则若 <script type="math/tex">z_k \neq y_j</script> ，那么， <script type="math/tex">Z_k</script> 是 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_{j-1}</script> 的一个最长公共子序列。注：此时 <script type="math/tex">z_k</script> 不一定等于 <script type="math/tex">x_i</script> ，但该推论是包含等于或不等于的情况的</li>
</ul>
<p>根据以上推论可进一步推断以下求解过程是与其等效的：</p>
<ul>
<li>当 <script type="math/tex">x_i=y_j</script> 时，首先找出 <script type="math/tex">X_{i-1}</script> 与 <script type="math/tex">Y_{j-1}</script> 的最长公共子序列，再在该子序列后面加上 <script type="math/tex">x_i</script> 或 <script type="math/tex">y_j</script> ，而后所得的子序列即为 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_j</script> 的最长公共子序列</li>
<li>而当 <script type="math/tex">x_i \neq y_j</script> 时，就需要分别求解 <script type="math/tex">X_{i-1}</script> 与 <script type="math/tex">Y_j</script> 以及 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_{j-1}</script> 的最长公共子序列，最后，所得的这两个子序列中的较长者即为 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_j</script> 的最长公共子序列</li>
</ul>
<p>若用 <script type="math/tex">\prod(i,j)</script> 表示 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_j</script> 的最长公共子序列，那么，将有如下公式成立：</p>
<script type="math/tex; mode=display">
\prod(i,j) = \begin{cases}
\prod(i-1,j-1) + x_i,                             & x_i = y_j \\
\max\big\{ \prod(i-1,j), \prod(i,j-1) \big\},     & x_i \neq y_j
\end{cases}
, i \geq 1, j \geq 1</script><blockquote>
<p>注意，公式中的加号表示序列与元素的连接，而不是数值的加减。<br>当 <script type="math/tex">i</script> 与 <script type="math/tex">j</script> 为 <script type="math/tex">1</script> 时，上面的公式将出现 <script type="math/tex">\prod(0,0)</script> ，而其正好表示的是 <script type="math/tex">X_{i-1}</script> 与 <script type="math/tex">Y_{j-1}</script> 的最长公共子序列为<strong>空序列</strong>，且其长度为 <script type="math/tex">0</script> 。</p>
</blockquote>
<p>从以上公式可以发现最长公共子序列问题具有<strong>子问题重叠</strong>的性质。因为，在求解 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_j</script> 的最长公共子序列时，需要分别求解 <script type="math/tex">X_{i-1}</script> 与 <script type="math/tex">Y_j</script> 以及 <script type="math/tex">X_i</script> 与 <script type="math/tex">Y_{j-1}</script> 的最长公共子序列，而这两个子问题都包含一个公共子问题，即，求解 <script type="math/tex">X_{i-1}</script> 与 <script type="math/tex">Y_{j-1}</script> 的最长公共子序列。</p>
<p>因此，可以采用<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">动态规划法</a>来求解最长公共子序列问题。</p>
<blockquote>
<p>动态规划在查找有很多<strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。（引用自「维基百科」）</p>
</blockquote>
<p>但是，若要寻找最长公共子序列，需要首先计算公共子序列的长度，再根据长度及坐标位置回溯才能寻找出 <script type="math/tex">X_i</script> 和 <script type="math/tex">Y_j</script> 的最长公共子序列。</p>
<p>因此，如果用二位数组 <script type="math/tex">f[i][j]</script> 表示序列 <script type="math/tex">X_i</script> 和 <script type="math/tex">Y_j</script> 的最长公共子序列的长度，那么根据前面的最长公共子序列的求解公式，便可相应地推导出求解最长公共子序列的长度的公式，即：</p>
<script type="math/tex; mode=display">
f[i][j] = \begin{cases}
0,                                           & i = 0 或 j = 0 \\
f[i-1][j-1] + 1,                             & i \geq 1, j \geq 1 且 x_i = y_j \\
\max\big\{ f[i-1][j], f[i][j-1] \big\},      & i \geq 1, j \geq 1 且 x_i \neq y_j
\end{cases}</script><p>这样， <script type="math/tex">f[i][j]</script> 中的最大值便是 <script type="math/tex">X_i</script> 和 <script type="math/tex">Y_j</script> 的最长公共子序列的长度，而根据该数组回溯，便可找到该最长公共子序列。</p>
<p>以序列 <script type="math/tex">X_i=\{ A, B, C, B, D, A, B \}</script> 和 <script type="math/tex">Y_j=\{ B, D, C, A, B, A \}</script> 为例，可以通过下图了解整个求解最长公共子序列长度的过程：</p>
<p><img src="/assets/images/algorithm/longest-common-sequence-dp-searching-case.png" alt></p>
<blockquote>
<p>上图取自于 <a href="https://blog.csdn.net/v_JULY_v/article/details/6110269" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/6110269</a></p>
</blockquote>
<p>这里直接给出实现代码，可以结合上图与代码进行分析（时间复杂度为 <script type="math/tex">O(mn)</script> ）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ_LEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    LEN_DIR_LEFT,</span><br><span class="line">    LEN_DIR_TOP,</span><br><span class="line">    LEN_DIR_TOP_LEFT</span><br><span class="line">&#125; LCSLenDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LCSLen</span> &#123;</span></span><br><span class="line">    <span class="comment">// 最长公共子序列的长度</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 长度求值基于哪个方向的结果，</span></span><br><span class="line">    <span class="comment">// 沿着该方向回溯便可反向找出对应的最长公共子序列</span></span><br><span class="line">    LCSLenDir dir;</span><br><span class="line">&#125; LCSLen;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note：二维数组作为参数时，必须指定第二维的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcs_search_dynamic_programming</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LCSLen lcs_len[][MAX_SEQ_LEN]</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> seq_x[], <span class="keyword">int</span> seq_y[]</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> seq_x_len, <span class="keyword">int</span> seq_y_len</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将(i,0)的单元格全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= seq_x_len; i++) &#123;</span><br><span class="line">        lcs_len[i][<span class="number">0</span>].value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将(0,j)的单元格全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= seq_y_len; j++) &#123;</span><br><span class="line">        lcs_len[<span class="number">0</span>][j].value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 沿着二维数组的i轴从上到下依次沿着j轴从左到右计算公共子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= seq_x_len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= seq_y_len; j++) &#123;</span><br><span class="line">            <span class="comment">// f[i][j] = f[i-1][j-1] + 1, x[i] = y[j]</span></span><br><span class="line">            <span class="comment">// Note：数组seq_x与seq_y的元素是从0开始的</span></span><br><span class="line">            <span class="keyword">if</span> (seq_x[i - <span class="number">1</span>] == seq_y[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                lcs_len[i][j].value = lcs_len[i - <span class="number">1</span>][j - <span class="number">1</span>].value + <span class="number">1</span>;</span><br><span class="line">                lcs_len[i][j].dir = LEN_DIR_TOP_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// f[i][j] = max(f[i-1][j], f[i][j-1])</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lcs_len[i - <span class="number">1</span>][j].value &gt;= lcs_len[i][j - <span class="number">1</span>].value) &#123;</span><br><span class="line">                lcs_len[i][j].value = lcs_len[i - <span class="number">1</span>][j].value;</span><br><span class="line">                lcs_len[i][j].dir = LEN_DIR_TOP;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lcs_len[i][j].value = lcs_len[i][j - <span class="number">1</span>].value;</span><br><span class="line">                lcs_len[i][j].dir = LEN_DIR_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>这里通过结构体<code>LCSLen</code>同时记录最长公共子序列的长度和方向，避免传递多个数组，可提升可读性</li>
<li>对于多个意义相同的固定的常量值，为其定义枚举类型，是一种良好的编码习惯</li>
<li>这里没有将<code>i</code>和<code>j</code>定义为函数的局部变量是为了在阅读时不用担心二者的值会被前面的逻辑所影响，因为前后的变量具有不同的作用域且是相互独立的。从而确保阅读的流畅性，同时，代码本身逻辑的内聚性也更强</li>
<li>需在确保良好的阅读体验的情况下对初始数据、方法参数列表等进行合理换行，避免在网页中出现横向滚动条，保证一眼可以看到全部内容</li>
</ul>
<p>在得到最长公共子序列的长度的二维数组后，便可从最右下角位置开始回溯并打印最长公共子序列（时间复杂度为 <script type="math/tex">O(m+n)</script> ）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_lcs</span><span class="params">(LCSLen lcs_len[][MAX_SEQ_LEN], <span class="keyword">int</span> seq_x[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lcs_len[i][j].dir == LEN_DIR_TOP_LEFT) &#123;</span><br><span class="line">        print_lcs(lcs_len, seq_x, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Note：i为序列X的下表，</span></span><br><span class="line">        <span class="comment">// 若要打印序列Y的元素，则应为 seq_y[j-1]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>, seq_x[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lcs_len[i][j].dir == LEN_DIR_TOP) &#123;</span><br><span class="line">        print_lcs(lcs_len, seq_x, i - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        print_lcs(lcs_len, seq_x, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/v_JULY_v/article/details/6110269" target="_blank" rel="noopener">动态规划算法解最长公共子序列LCS问题</a>：详细讲解了动态规划法的实现过程并给出了对空间复杂度进行优化后的实现代码</li>
<li><a href="https://blog.csdn.net/hrn1216/article/details/51534607" target="_blank" rel="noopener">动态规划最长公共子序列过程图解</a>：图例丰富有助于理解求解的动态过程</li>
<li><a href="https://blog.csdn.net/so_geili/article/details/53737001" target="_blank" rel="noopener">算法导论-最长公共子序列LCS（动态规划）</a>：介绍了蛮力搜索和动态规划两种方式，也同样给出了进行空间优化后的代码（实现较前面的文章更简单、清晰）。注：蛮力搜索的时间复杂度为 <script type="math/tex">O(n2^m)</script></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>以下为完整的各方案代码，并包含性能测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ_LEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    LEN_DIR_LEFT,</span><br><span class="line">    LEN_DIR_TOP,</span><br><span class="line">    LEN_DIR_TOP_LEFT</span><br><span class="line">&#125; LCSLenDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LCSLen</span> &#123;</span></span><br><span class="line">    <span class="comment">// 最长公共子序列的长度</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 长度求值基于哪个方向的结果，</span></span><br><span class="line">    <span class="comment">// 沿着该方向回溯便可反向找出对应的最长公共子序列</span></span><br><span class="line">    LCSLenDir dir;</span><br><span class="line">&#125; LCSLen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_lcs</span><span class="params">(LCSLen lcs_len[][MAX_SEQ_LEN], <span class="keyword">int</span> seq_x[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcs_search_dynamic_programming</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LCSLen lcs_len[][MAX_SEQ_LEN]</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> seq_x[], <span class="keyword">int</span> seq_y[]</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> seq_x_len, <span class="keyword">int</span> seq_y_len</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seq_x[] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>&#125;;</span><br><span class="line">    <span class="comment">// int seq_x[] = &#123;'A', 'C', 'C', 'G', 'G', 'T', 'C'</span></span><br><span class="line">    <span class="comment">//                 , 'G', 'A', 'G', 'T', 'G', 'C', 'G'</span></span><br><span class="line">    <span class="comment">//                 , 'C', 'G', 'G', 'A', 'A', 'G', 'C'</span></span><br><span class="line">    <span class="comment">//                 , 'C', 'G', 'G', 'C', 'C', 'G', 'A'</span></span><br><span class="line">    <span class="comment">//                 , 'A'&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> seq_x_len = <span class="keyword">sizeof</span>(seq_x) / <span class="keyword">sizeof</span>(seq_x[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq_y[] = &#123;<span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>&#125;;</span><br><span class="line">    <span class="comment">// int seq_y[] = &#123;'G', 'T', 'C', 'G', 'T', 'T', 'C'</span></span><br><span class="line">    <span class="comment">//                 , 'G', 'G', 'A', 'A', 'T', 'G', 'C'</span></span><br><span class="line">    <span class="comment">//                 , 'C', 'G', 'T', 'T', 'G', 'C', 'T'</span></span><br><span class="line">    <span class="comment">//                 , 'C', 'T', 'G', 'T', 'A', 'A', 'A'&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> seq_y_len = <span class="keyword">sizeof</span>(seq_y) / <span class="keyword">sizeof</span>(seq_y[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    LCSLen lcs_len[MAX_SEQ_LEN][MAX_SEQ_LEN];</span><br><span class="line"></span><br><span class="line">    lcs_search_dynamic_programming(lcs_len, seq_x, seq_y, seq_x_len, seq_y_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最长公共子序列的长度为: %d\n"</span>, lcs_len[seq_x_len][seq_y_len].value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"其中一个最长公共子序列为: "</span>);</span><br><span class="line">    print_lcs(lcs_len, seq_x, seq_x_len, seq_y_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note：二维数组作为参数时，必须指定第二维的长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcs_search_dynamic_programming</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LCSLen lcs_len[][MAX_SEQ_LEN]</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> seq_x[], <span class="keyword">int</span> seq_y[]</span></span></span><br><span class="line"><span class="function"><span class="params">    , <span class="keyword">int</span> seq_x_len, <span class="keyword">int</span> seq_y_len</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将(i,0)的单元格全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= seq_x_len; i++) &#123;</span><br><span class="line">        lcs_len[i][<span class="number">0</span>].value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将(0,j)的单元格全部置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= seq_y_len; j++) &#123;</span><br><span class="line">        lcs_len[<span class="number">0</span>][j].value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 沿着二维数组的i轴从上到下依次沿着j轴从左到右计算公共子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= seq_x_len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= seq_y_len; j++) &#123;</span><br><span class="line">            <span class="comment">// f[i][j] = f[i-1][j-1] + 1, x[i] = y[j]</span></span><br><span class="line">            <span class="comment">// Note：数组seq_x与seq_y的元素是从0开始的</span></span><br><span class="line">            <span class="keyword">if</span> (seq_x[i - <span class="number">1</span>] == seq_y[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                lcs_len[i][j].value = lcs_len[i - <span class="number">1</span>][j - <span class="number">1</span>].value + <span class="number">1</span>;</span><br><span class="line">                lcs_len[i][j].dir = LEN_DIR_TOP_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// f[i][j] = max(f[i-1][j], f[i][j-1])</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lcs_len[i - <span class="number">1</span>][j].value &gt;= lcs_len[i][j - <span class="number">1</span>].value) &#123;</span><br><span class="line">                lcs_len[i][j].value = lcs_len[i - <span class="number">1</span>][j].value;</span><br><span class="line">                lcs_len[i][j].dir = LEN_DIR_TOP;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lcs_len[i][j].value = lcs_len[i][j - <span class="number">1</span>].value;</span><br><span class="line">                lcs_len[i][j].dir = LEN_DIR_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_lcs</span><span class="params">(LCSLen lcs_len[][MAX_SEQ_LEN], <span class="keyword">int</span> seq_x[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lcs_len[i][j].dir == LEN_DIR_TOP_LEFT) &#123;</span><br><span class="line">        print_lcs(lcs_len, seq_x, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Note：i为序列X的下表，</span></span><br><span class="line">        <span class="comment">// 若要打印序列Y的元素，则应为 seq_y[j-1]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>, seq_x[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lcs_len[i][j].dir == LEN_DIR_TOP) &#123;</span><br><span class="line">        print_lcs(lcs_len, seq_x, i - <span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        print_lcs(lcs_len, seq_x, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:flytreeleft@126.com">flytreeleft</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://flytreeleft.github.io/algorithm-finding-the-longest-common-sequence/">https://flytreeleft.github.io/algorithm-finding-the-longest-common-sequence/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">知识共享署名 4.0 国际许可协议</a> 许可协议。转载请注明来自 <a href="https://flytreeleft.github.io" target="_blank">flytreeleft's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/动态规划/">动态规划</a><a class="post-meta__tags" href="/tags/最长公共子序列/">最长公共子序列</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/assets/profile/wechatpay.png"><div class="post-qr-code__desc"></div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/assets/profile/alipay.png"><div class="post-qr-code__desc"></div></div></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/the-jvm-dump-analyse-for-tomcat-memory-leak/"><i class="fa fa-chevron-left">  </i><span>JVM内存分析：Tomcat内存泄漏</span></a></div><div class="next-post pull-right"><a href="/algorithm-calculating-maximum-interval-sum/"><span>算法分析：求解最大子段和</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By flytreeleft</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu/js/anti-baidu-latest.min.js"></script><script src="/js/utils.js?version=1.3"></script><script src="/js/fancybox.js?version=1.3"></script><script src="/js/sidebar.js?version=1.3"></script><script src="/js/copy.js?version=1.3"></script><script src="/js/fireworks.js?version=1.3"></script><script src="/js/transition.js?version=1.3"></script><script src="/js/scroll.js?version=1.3"></script><script src="/js/head.js?version=1.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>