<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="算法分析：分治法求解给定集合中的众数及其重数"><meta name="keywords" content="分治法,众数,重数"><meta name="author" content="flytreeleft,flytreeleft@126.com"><meta name="copyright" content="flytreeleft"><title>算法分析：分治法求解给定集合中的众数及其重数 | flytreeleft's Blog</title><link rel="shortcut icon" href="/assets/profile/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题描述"><span class="toc-number">1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解思路"><span class="toc-number">2.</span> <span class="toc-text">求解思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现代码"><span class="toc-number">3.</span> <span class="toc-text">实现代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现改进"><span class="toc-number">4.</span> <span class="toc-text">实现改进</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/assets/profile/avatar.jpg"></div><div class="author-info__name text-center">flytreeleft</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://coolshell.cn/" target="_blank">酷壳</a><a class="author-info-links__name text-center" href="https://www.infoq.com/" target="_blank">InfoQ</a><a class="author-info-links__name text-center" href="http://www.yinwang.org/" target="_blank">当然我在扯淡</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/assets/profile/walle-watch-the-stars-sky.jpg);"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">flytreeleft's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/quotes">Quotes</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">算法分析：分治法求解给定集合中的众数及其重数</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/算法分析/">算法分析</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2,982</span><span class="post-meta__separator">|</span><span>阅读时长: 12 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>算法分析系列文章中的代码可被任何人无偿使用于任何场景且无需注明来源也不必在使用前征得本文作者同意。</p>
<p>算法分析系列文章旨在传播准确、完整、简洁、易懂、规范的代码实现，并传授基本的编程思想和良好的编码习惯与技巧。</p>
<p>若文章中的代码存在问题或逻辑错误，请通过邮件等形式（见文章结尾）告知于本文作者以便及时修正错误或改进代码。</p>
<p>PS：若为转载该文章，请务必注明来源，本站点欢迎大家转载。</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定含有n个元素的多重集合<code>S</code>，每个元素在<code>S</code>中<u>出现的次数</u>称为该元素的<strong>重数</strong>。多重集<code>S</code>中<u>重数最大的元素</u>称为<a href="https://zh.wikipedia.org/wiki/%E4%BC%97%E6%95%B0_(%E6%95%B0%E5%AD%A6)" target="_blank" rel="noopener">众数</a>（<strong>mode</strong>）。</p>
<p>例如，<code>S={1，2，2，2，3，5}</code>，则，多重集<code>S</code>的众数是<code>2</code>，其重数为<code>3</code>。</p>
<blockquote>
<p>注：众数可能存在多个。</p>
</blockquote>
<p>本案例要求采用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="noopener">分治法</a>求解给定集合中的众数及其重数，存在多个众数时选择第一个即可。</p>
<blockquote>
<p>分治法，即，把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。（引用自「维基百科」）<br><a id="more"></a></p>
</blockquote>
<h2 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h2><p>分治法求解的基本思路就是将集合分成几个小部分，依次查找每个部分中的众数，再从每个部分中取出重数最大的数，该数即为所求解的众数。</p>
<p>在分治求解过程中，当枢轴元素（<strong>pivot</strong>）所在位置的左右两侧剩余的数据量均小于<code>pivot</code>的重数时，则求解结束且所求的众数即为<code>pivot</code>的值。</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_mode; <span class="comment">// 众数值</span></span><br><span class="line"><span class="keyword">int</span> g_cnt = <span class="number">0</span>; <span class="comment">// 众数的重数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先声明相关函数定义以便于按照阅读先后顺序排列函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_find_mode</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_and_find_pivot</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_element</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> index_0, <span class="keyword">int</span> index_1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int data[] = &#123;'a', 'a', 'b', 'b', 'b', '1', '2', '1'&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//int data[] = &#123;10&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;1, 2, 3&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;1, 2, 2, 2, 3, 3, 5, 6, 6, 6, 6&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;1, 2, 7, 7, 3, 5&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;3, 6, 7, 6, 4, 5&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">    divide_find_mode(data, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"众数为: %d, 且其重数为: %d\n"</span>, g_mode, g_cnt);</span><br><span class="line">    <span class="comment">// 当集合元素为char类型时，使用以下方式输出结果</span></span><br><span class="line">    <span class="comment">//printf("众数为: %c, 且其重数为: %d\n", g_mode, g_cnt);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用分治法查找集合data在指定范围（[start_index, end_index]区间）内的众数及其重数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_find_mode</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot_index = sort_and_find_pivot(data, start_index, end_index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从右边开始统计与pivot相等的元素个数（包括pivot本身）</span></span><br><span class="line">    <span class="keyword">int</span> pivot_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start_index; i &lt;= pivot_index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] == data[pivot_index]) &#123;</span><br><span class="line">            pivot_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录重数最大的元素及其重数值</span></span><br><span class="line">    <span class="keyword">if</span> (pivot_cnt &gt; g_cnt) &#123;</span><br><span class="line">        g_mode = data[pivot_index];</span><br><span class="line">        g_cnt = pivot_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若左边剩余元素数量大于当前的重数值，则继续寻找左边剩余元素（范围为[start_index, pivot_index - 1]）中的众数</span></span><br><span class="line">    <span class="comment">// 左边剩余元素数量 = 当前众数位置左移一位（pivot_index - 1） - 查询的开始位置序号 + 1</span></span><br><span class="line">    <span class="comment">// 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）左边剩余元素数量为2（即，2 - 1 - 0 + 1）</span></span><br><span class="line">    <span class="keyword">if</span> ((pivot_index - <span class="number">1</span>) - start_index + <span class="number">1</span> &gt; pivot_cnt) &#123;</span><br><span class="line">        divide_find_mode(data, start_index, pivot_index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若右边剩余元素数量大于当前的重数值，则继续寻找右边剩余元素（范围为[pivot_index + 1, end_index]）中的众数</span></span><br><span class="line">    <span class="comment">// 右边剩余元素数量 = 查询的结束位置序号 - 当前众数位置右移一位（pivot_index + 1） + 1</span></span><br><span class="line">    <span class="comment">// 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）右边剩余元素数量为2（即，4 - (2 + 1) + 1）</span></span><br><span class="line">    <span class="keyword">if</span> (end_index - (pivot_index + <span class="number">1</span>) + <span class="number">1</span> &gt; pivot_cnt) &#123;</span><br><span class="line">        divide_find_mode(data, pivot_index + <span class="number">1</span>, end_index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在集合data的指定范围（[start_index, end_index]区间）内选择一个枢轴元素（pivot）并进行排序，</span></span><br><span class="line"><span class="comment">// 以确保在该范围内pivot左边的元素均小于或等于pivot，而右边的则均大于pivot</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_and_find_pivot</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取开始位置的元素作为枢轴元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = data[start_index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_index = start_index;</span><br><span class="line">    <span class="keyword">int</span> right_index = end_index;</span><br><span class="line">    <span class="comment">// 从两边向中间推进以调整元素位置，最终确保左边的元素小于或等于pivot，而右边的元素大于pivot</span></span><br><span class="line">    <span class="keyword">while</span> (left_index &lt; right_index) &#123;</span><br><span class="line">        <span class="comment">// 从右边向中间推进直到遇到小于或等于pivot的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left_index &lt; right_index &amp;&amp; data[right_index] &gt; pivot) &#123;</span><br><span class="line">            right_index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左边向中间推进直到遇到大于pivot的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left_index &lt; right_index &amp;&amp; data[left_index] &lt;= pivot) &#123;</span><br><span class="line">            left_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 左边大于pivot的元素 与 右边小于或等于pivot的元素 交换位置</span></span><br><span class="line">        swap_element(data, left_index, right_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note：在排序过程中start_index位置的元素是不会变动位置的（其必然等于pivot），</span></span><br><span class="line">    <span class="comment">// 而left_index位置的元素为最后一个小于或等于pivot的元素，</span></span><br><span class="line">    <span class="comment">// 这时交换二者位置后，便可确保pivot左边的元素均小于或等于pivot了</span></span><br><span class="line">    swap_element(data, start_index, left_index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换集合data中两个指定元素位置（index_0与index_1）的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_element</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> index_0, <span class="keyword">int</span> index_1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = data[index_0];</span><br><span class="line"></span><br><span class="line">    data[index_0] = data[index_1];</span><br><span class="line">    data[index_1] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码应该能够很容易看懂。这里主要强调以下几点：</p>
<ul>
<li>对外传播的代码应该尽量降低阅读者的理解难度以及<strong>时间成本</strong></li>
<li>变量名、函数名一定要能够清晰、准确地传达出其所代表的东西以及其职能，不要简单使用<code>i</code>、<code>j</code>等无意义的名称，更不要使用语义不清甚至是错误的单词</li>
<li>函数实现代码一般按照调用先后顺序和重要性进行排列以便于阅读并突出关键实现等</li>
<li>注释主要用于阐明流程、算法机制和原理、特殊代码技巧以及在调整或改进时需特别注意的事项等内容，切记不要对代码本身进行说明，说明也不要<strong>又臭又长</strong>。PS：本文为了能让刚入门的开发者看懂并阐述算法机制和过程，所以，注释写得比较详细，在实际开发中可以默认视为阅读者具备相关的算法基础，从而无需再对算法进行注释说明</li>
<li>一般通过<code>sizeof(data) / sizeof(data[0])</code>方式动态计算数组长度</li>
</ul>
<h2 id="实现改进"><a href="#实现改进" class="headerlink" title="实现改进"></a>实现改进</h2><p>上面的代码在调用<code>sort_and_find_pivot()</code>后存在一次遍历以获得<code>pivot</code>的重数（<code>pivot_cnt</code>），但实际上在<code>sort_and_find_pivot()</code>排序过程中已经存在等值比较，在这个时候是可以顺便得到<code>pivot</code>的重数的，只是限于C语言的函数只能返回一个值的约束而无法同时返回其重数。不过，C语言提供结构体类型，故而，可以通过在<code>sort_and_find_pivot()</code>后返回结构体的方式以避免不必要的遍历。</p>
<p>以下为改进后的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Mode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 众数值</span></span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">// 众数重复次数，即重数</span></span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 主要用于在查找pivot时记录其最终位置</span></span><br><span class="line">&#125; Mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先声明相关函数定义以便于按照阅读先后顺序排列函数实现</span></span><br><span class="line"><span class="function">Mode <span class="title">divide_find_mode</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span></span>;</span><br><span class="line"><span class="function">Mode <span class="title">sort_and_find_pivot</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_element</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> index_0, <span class="keyword">int</span> index_1)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_mode</span><span class="params">(Mode mode_0, Mode mode_1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int data[] = &#123;'a', 'a', 'b', 'b', 'b', '1', '2', '1'&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//int data[] = &#123;10&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;1, 2, 3&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;1, 2, 2, 2, 3, 3, 5, 6, 6, 6, 6&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;1, 2, 7, 7, 3, 5&#125;;</span></span><br><span class="line">    <span class="comment">//int data[] = &#123;3, 6, 7, 6, 4, 5&#125;;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    Mode mode = divide_find_mode(data, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"众数为: %d, 且其重数为: %d\n"</span>, mode.value, mode.count);</span><br><span class="line">    <span class="comment">// 当集合元素为char类型时，使用以下方式输出结果</span></span><br><span class="line">    <span class="comment">//printf("众数为: %c, 且其重数为: %d\n", mode.value, mode.count);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用分治法查找集合data在指定范围（[start_index, end_index]区间）内的众数及其重数</span></span><br><span class="line"><span class="function">Mode <span class="title">divide_find_mode</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span> </span>&#123;</span><br><span class="line">    Mode pivot = sort_and_find_pivot(data, start_index, end_index);</span><br><span class="line"></span><br><span class="line">    Mode mode = pivot;</span><br><span class="line">    <span class="comment">// 若左边剩余元素数量大于当前的重数值，则继续寻找左边剩余元素（范围为[start_index, pivot.index - 1]）中的众数</span></span><br><span class="line">    <span class="comment">// 左边剩余元素数量 = 当前众数位置左移一位（pivot.index - 1） - 查询的开始位置序号 + 1</span></span><br><span class="line">    <span class="comment">// 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）左边剩余元素数量为2（即，2 - 1 - 0 + 1）</span></span><br><span class="line">    <span class="keyword">if</span> ((pivot.index - <span class="number">1</span>) - start_index + <span class="number">1</span> &gt; pivot.count) &#123;</span><br><span class="line">        Mode m = divide_find_mode(data, start_index, pivot.index - <span class="number">1</span>);</span><br><span class="line">        mode = compare_mode(m, mode) &gt; <span class="number">0</span> ? m : mode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若右边剩余元素数量大于当前的重数值，则继续寻找右边剩余元素（范围为[pivot.index + 1, end_index]）中的众数</span></span><br><span class="line">    <span class="comment">// 右边剩余元素数量 = 查询的结束位置序号 - 当前众数位置右移一位（pivot.index + 1） + 1</span></span><br><span class="line">    <span class="comment">// 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）右边剩余元素数量为2（即，4 - (2 + 1) + 1）</span></span><br><span class="line">    <span class="keyword">if</span> (end_index - (pivot.index + <span class="number">1</span>) + <span class="number">1</span> &gt; pivot.count) &#123;</span><br><span class="line">        Mode m = divide_find_mode(data, pivot.index + <span class="number">1</span>, end_index);</span><br><span class="line">        mode = compare_mode(m, mode) &gt; <span class="number">0</span> ? m : mode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在集合data的指定范围（[start_index, end_index]区间）内选择一个枢轴元素（pivot）并进行排序，</span></span><br><span class="line"><span class="comment">// 以确保在该范围内pivot左边的元素均小于或等于pivot，而右边的则均大于pivot</span></span><br><span class="line"><span class="function">Mode <span class="title">sort_and_find_pivot</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> start_index, <span class="keyword">int</span> end_index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_index = start_index;</span><br><span class="line">    <span class="keyword">int</span> right_index = end_index;</span><br><span class="line"></span><br><span class="line">    Mode pivot = &#123;</span><br><span class="line">        <span class="comment">// 取开始位置的元素作为枢轴元素</span></span><br><span class="line">        .value = data[start_index],</span><br><span class="line">        <span class="comment">// 当只有一个元素时，则不会进行排序，也就不会有等值判断，故，count将始终为1</span></span><br><span class="line">        .count = left_index == right_index ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从两边向中间推进以调整元素位置，最终确保左边的元素小于或等于pivot，而右边的元素大于pivot</span></span><br><span class="line">    <span class="keyword">while</span> (left_index &lt; right_index) &#123;</span><br><span class="line">        <span class="comment">// 从右边向中间推进直到遇到小于或等于pivot的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left_index &lt; right_index &amp;&amp; data[right_index] &gt; pivot.value) &#123;</span><br><span class="line">            right_index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left_index &lt; right_index &amp;&amp; data[right_index] == pivot.value) &#123;</span><br><span class="line">            pivot.count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左边向中间推进直到遇到大于pivot的元素</span></span><br><span class="line">        <span class="keyword">while</span> (left_index &lt; right_index &amp;&amp; data[left_index] &lt;= pivot.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[left_index] == pivot.value) &#123;</span><br><span class="line">                pivot.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            left_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 左边大于pivot的元素 与 右边小于或等于pivot的元素 交换位置</span></span><br><span class="line">        swap_element(data, left_index, right_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note：在排序过程中start_index位置的元素是不会变动位置的（其必然等于pivot），</span></span><br><span class="line">    <span class="comment">// 而left_index位置的元素为最后一个小于或等于pivot的元素，</span></span><br><span class="line">    <span class="comment">// 这时交换二者位置后，便可确保pivot左边的元素均小于或等于pivot了</span></span><br><span class="line">    swap_element(data, start_index, left_index);</span><br><span class="line"></span><br><span class="line">    pivot.index = left_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换集合data中两个指定元素位置（index_0与index_1）的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_element</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> index_0, <span class="keyword">int</span> index_1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index_0 == index_1) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = data[index_0];</span><br><span class="line"></span><br><span class="line">    data[index_0] = data[index_1];</span><br><span class="line">    data[index_1] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_mode</span><span class="params">(Mode mode_0, Mode mode_1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mode_0.count - mode_1.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要强调以下几点：</p>
<ul>
<li>在离调用最近的位置处声明变量，避免变量声明位置与第一次使用位置相隔太远</li>
<li>结构体数据的初始化采用<a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html" target="_blank" rel="noopener">(ANSI) C99</a>方式以便于阅读，如，<code>struct point p = { .y = yvalue, .x = xvalue };</code></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:flytreeleft@126.com">flytreeleft</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://flytreeleft.github.io/algorithm-using-divide-and-conquer-method-to-find-the-mode-in-a-set/">https://flytreeleft.github.io/algorithm-using-divide-and-conquer-method-to-find-the-mode-in-a-set/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">知识共享署名 4.0 国际许可协议</a> 许可协议。转载请注明来自 <a href="https://flytreeleft.github.io" target="_blank">flytreeleft's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/分治法/">分治法</a><a class="post-meta__tags" href="/tags/众数/">众数</a><a class="post-meta__tags" href="/tags/重数/">重数</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/assets/profile/wechatpay.png"><div class="post-qr-code__desc"></div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/assets/profile/alipay.png"><div class="post-qr-code__desc"></div></div></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/algorithm-calculating-fibonacci-numbers/"><i class="fa fa-chevron-left">  </i><span>算法分析：求解斐波那契数列</span></a></div><div class="next-post pull-right"><a href="/a-horrible-os-upgrading-for-centos/"><span>记一次惊心动魄的CentOS系统升级经历</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2018 By flytreeleft</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu/js/anti-baidu-latest.min.js"></script><script src="/js/utils.js?version=1.3"></script><script src="/js/fancybox.js?version=1.3"></script><script src="/js/sidebar.js?version=1.3"></script><script src="/js/copy.js?version=1.3"></script><script src="/js/fireworks.js?version=1.3"></script><script src="/js/transition.js?version=1.3"></script><script src="/js/scroll.js?version=1.3"></script><script src="/js/head.js?version=1.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>