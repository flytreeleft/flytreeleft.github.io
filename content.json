{"pages":[{"title":"About me","permalink":"https://flytreeleft.github.io/about/index.html","text":"Nothing more!"},{"title":"Categories","permalink":"https://flytreeleft.github.io/categories/index.html","text":""},{"title":"Simple words for me and you","permalink":"https://flytreeleft.github.io/quotes/index.html","text":"Time is your best precious treasure, please use it as better as you can.时间是你拥有的最大财富，请好好利用它！ There is no retribution only cause and result.这世间没有「报应」，只有「因果」。 The other’s success isn’t yours, but the failure will be.成功者的成功不会是你的成功，失败者的失败必然是你的失败。 Thousands of little steps make the great miles away, thousands of little rivers make the great ocean.不积跬步，无以至千里；不积小流，无以成江海。 If no actions, your dream will still be a dream forever.如果不付诸行动，你的梦想将永远只是梦想。 Human beings are not afraid of the death, but they are just obsessed with something.人类害怕的并不是死亡本身，只是对某些东西会念念不忘而以。"},{"title":"Tags","permalink":"https://flytreeleft.github.io/tags/index.html","text":""}],"posts":[{"title":"算法分析：分治法求解给定集合中的众数及其重数","permalink":"https://flytreeleft.github.io/algorithm-find-mode-via-divide-md/","text":"算法分析系列文章中的代码可被任何人无偿使用于任何场景且无需注明来源也不必在使用前征得本文作者同意。 算法分析系列文章旨在传播准确、完整、简洁、易懂、规范的代码实现，并传授基本的编程思想和良好的编码习惯与技巧。 若文章中的代码存在问题或逻辑错误，请通过邮件等形式（见文章结尾）告知于本文作者以便及时修正错误或改进代码。 PS：若为转载该文章，请务必注明来源，本站点欢迎大家转载。 问题描述给定含有n个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集S中重数最大的元素称为众数)（mode）。 例如，S={1，2，2，2，3，5}，则，多重集S的众数是2，其重数为3。 注：众数可能存在多个。 本案例要求采用分治法求解给定集合中的众数及其重数，存在多个众数时选择第一个即可。 求解思路分治法求解的基本思路就是将集合分成几个小部分，依次查找每个部分中的众数，再从每个部分中取出重数最大的数，该数即为所求解的众数。 在分治求解过程中，当枢轴元素（pivot）所在位置的左右两侧剩余的数据量均小于pivot的重数时，则求解结束且所求的众数即为pivot的值。 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int g_mode; // 众数值int g_cnt = 0; // 众数的重数值// 优先声明相关函数定义以便于按照阅读先后顺序排列函数实现void divide_find_mode(int data[], int start_index, int end_index);int sort_and_find_pivot(int data[], int start_index, int end_index);void swap_element(int data[], int index_0, int index_1);int main(void) &#123; //int data[] = &#123;'a', 'a', 'b', 'b', 'b', '1', '2', '1'&#125;; int data[] = &#123;2, 4, 7, 8, 5, 6, 5, 5, 6, 7, 1&#125;; //int data[] = &#123;1, 2, 2, 2, 3, 3, 5, 6, 6, 6, 6&#125;; //int data[] = &#123;1, 2, 7, 7, 3, 5&#125;; //int data[] = &#123;3, 6, 7, 6, 4, 5&#125;; int len = sizeof(data) / sizeof(data[0]); divide_find_mode(data, 0, len - 1); printf(\"众数为: %d, 且其重数为: %d\\n\", g_mode, g_cnt); // 当集合元素为char类型时，使用以下方式输出结果 //printf(\"众数为: %c, 且其重数为: %d\\n\", g_mode, g_cnt); return 0;&#125;// 采用分治法查找集合data在指定范围（[start_index, end_index]区间）内的众数及其重数void divide_find_mode(int data[], int start_index, int end_index) &#123; int pivot_index = sort_and_find_pivot(data, start_index, end_index); // 从右边开始统计与pivot相等的元素个数（包括pivot本身） int pivot_cnt = 0; for (int i = start_index; i &lt;= pivot_index; i++) &#123; if (data[i] == data[pivot_index]) &#123; pivot_cnt++; &#125; &#125; // 记录重数最大的元素及其重数值 if (pivot_cnt &gt; g_cnt) &#123; g_mode = data[pivot_index]; g_cnt = pivot_cnt; &#125; // 若左边剩余元素数量大于当前的重数值，则继续寻找左边剩余元素（范围为[start_index, pivot_index - 1]）中的众数 // 左边剩余元素数量 = 当前众数位置左移一位（pivot_index - 1） - 查询的开始位置序号 + 1 // 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）左边剩余元素数量为2（即，2 - 1 - 0 + 1） if ((pivot_index - 1) - start_index + 1 &gt; pivot_cnt) &#123; divide_find_mode(data, start_index, pivot_index - 1); &#125; // 若右边剩余元素数量大于当前的重数值，则继续寻找右边剩余元素（范围为[pivot_index + 1, end_index]）中的众数 // 右边剩余元素数量 = 查询的结束位置序号 - 当前众数位置右移一位（pivot_index + 1） + 1 // 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）右边剩余元素数量为2（即，4 - (2 + 1) + 1） if (end_index - (pivot_index + 1) + 1 &gt; pivot_cnt) &#123; divide_find_mode(data, pivot_index + 1, end_index); &#125;&#125;// 在集合data的指定范围（[start_index, end_index]区间）内选择一个枢轴元素（pivot）并进行排序，// 以确保在该范围内pivot左边的元素均小于或等于pivot，而右边的则均大于pivotint sort_and_find_pivot(int data[], int start_index, int end_index) &#123; // 取开始位置的元素作为枢轴元素 int pivot = data[start_index]; int left_index = start_index; int right_index = end_index; // 从两边向中间推进以调整元素位置，最终确保左边的元素小于或等于pivot，而右边的元素大于pivot while (left_index &lt; right_index) &#123; // 从右边向中间推进直到遇到小于或等于pivot的元素 while (left_index &lt; right_index &amp;&amp; data[right_index] &gt; pivot) &#123; right_index--; &#125; // 从左边向中间推进直到遇到大于pivot的元素 while (left_index &lt; right_index &amp;&amp; data[left_index] &lt;= pivot) &#123; left_index++; &#125; // 将 左边大于pivot的元素 与 右边小于或等于pivot的元素 交换位置 swap_element(data, left_index, right_index); &#125; // Note：在排序过程中start_index位置的元素是不会变动位置的（其必然等于pivot）， // 而left_index位置的元素为最后一个小于或等于pivot的元素， // 这时交换二者位置后，便可确保pivot左边的元素均小于或等于pivot了 swap_element(data, start_index, left_index); return left_index;&#125;// 交换集合data中两个指定元素位置（index_0与index_1）的数据void swap_element(int data[], int index_0, int index_1) &#123; int temp = data[index_0]; data[index_0] = data[index_1]; data[index_1] = temp;&#125; 以上代码应该能够很容易看懂。这里主要强调以下几点： 对外传播的代码应该尽量降低阅读者的理解难度以及时间成本 变量名、函数名一定要能够清晰、准确地传达出其所代表的东西以及其职能，不要简单使用i、j等无意义的名称，更不要使用语义不清甚至是错误的单词 函数实现代码一般按照调用先后顺序和重要性进行排列以便于阅读并突出关键实现等 注释主要用于阐明流程、算法机制和原理、特殊代码技巧以及在调整或改进时需特别注意的事项等内容，切记不要对代码本身进行说明，说明也不要又臭又长。PS：本文为了能让刚入门的开发者看懂并阐述算法机制和过程，所以，注释写得比较详细，在实际开发中可以默认视为阅读者具备相关的算法基础，从而无需再对算法进行注释说明 一般通过sizeof(data) / sizeof(data[0])方式动态计算数组长度 实现改进上面的代码在调用sort_and_find_pivot()后存在一次遍历以获得pivot的重数（pivot_cnt），但实际上在sort_and_find_pivot()排序过程中已经存在等值比较，在这个时候是可以顺便得到pivot的重数的，只是限于C语言的函数只能返回一个值的约束而无法同时返回其重数。不过，C语言提供结构体类型，故而，可以通过在sort_and_find_pivot()后返回结构体的方式以避免不必要的遍历。 以下为改进后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct _Mode &#123; int value; // 众数值 int count; // 众数重复次数，即重数 int index; // 主要用于在查找pivot时记录其最终位置&#125; Mode;// 优先声明相关函数定义以便于按照阅读先后顺序排列函数实现Mode divide_find_mode(int data[], int start_index, int end_index);Mode sort_and_find_pivot(int data[], int start_index, int end_index);void swap_element(int data[], int index_0, int index_1);int compare_mode(Mode mode_0, Mode mode_1);int main(void) &#123; //int data[] = &#123;'a', 'a', 'b', 'b', 'b', '1', '2', '1'&#125;; int data[] = &#123;2, 4, 7, 8, 5, 6, 5, 5, 6, 7, 1&#125;; //int data[] = &#123;1, 2, 2, 2, 3, 3, 5, 6, 6, 6, 6&#125;; //int data[] = &#123;1, 2, 7, 7, 3, 5&#125;; //int data[] = &#123;3, 6, 7, 6, 4, 5&#125;; int len = sizeof(data) / sizeof(data[0]); Mode mode = divide_find_mode(data, 0, len - 1); printf(\"众数为: %d, 且其重数为: %d\\n\", mode.value, mode.count); // 当集合元素为char类型时，使用以下方式输出结果 //printf(\"众数为: %c, 且其重数为: %d\\n\", mode.value, mode.count); return 0;&#125;// 采用分治法查找集合data在指定范围（[start_index, end_index]区间）内的众数及其重数Mode divide_find_mode(int data[], int start_index, int end_index) &#123; Mode pivot = sort_and_find_pivot(data, start_index, end_index); Mode mode = pivot; // 若左边剩余元素数量大于当前的重数值，则继续寻找左边剩余元素（范围为[start_index, pivot.index - 1]）中的众数 // 左边剩余元素数量 = 当前众数位置左移一位（pivot.index - 1） - 查询的开始位置序号 + 1 // 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）左边剩余元素数量为2（即，2 - 1 - 0 + 1） if ((pivot.index - 1) - start_index + 1 &gt; pivot.count) &#123; Mode m = divide_find_mode(data, start_index, pivot.index - 1); mode = compare_mode(m, mode) &gt; 0 ? m : mode; &#125; // 若右边剩余元素数量大于当前的重数值，则继续寻找右边剩余元素（范围为[pivot.index + 1, end_index]）中的众数 // 右边剩余元素数量 = 查询的结束位置序号 - 当前众数位置右移一位（pivot.index + 1） + 1 // 如，数组&#123;1, 2, 3, 4， 5&#125;中3（其序号为2）右边剩余元素数量为2（即，4 - (2 + 1) + 1） if (end_index - (pivot.index + 1) + 1 &gt; pivot.count) &#123; Mode m = divide_find_mode(data, pivot.index + 1, end_index); mode = compare_mode(m, mode) &gt; 0 ? m : mode; &#125; return mode;&#125;// 在集合data的指定范围（[start_index, end_index]区间）内选择一个枢轴元素（pivot）并进行排序，// 以确保在该范围内pivot左边的元素均小于或等于pivot，而右边的则均大于pivotMode sort_and_find_pivot(int data[], int start_index, int end_index) &#123; int left_index = start_index; int right_index = end_index; Mode pivot = &#123; // 取开始位置的元素作为枢轴元素 .value = data[start_index], // 当只有一个元素时，则不会进行排序，也就不会有等值判断，故，count将始终为1 .count = left_index == right_index ? 1 : 0 &#125;; // 从两边向中间推进以调整元素位置，最终确保左边的元素小于或等于pivot，而右边的元素大于pivot while (left_index &lt; right_index) &#123; // 从右边向中间推进直到遇到小于或等于pivot的元素 while (left_index &lt; right_index &amp;&amp; data[right_index] &gt; pivot.value) &#123; right_index--; &#125; if (left_index &lt; right_index &amp;&amp; data[right_index] == pivot.value) &#123; pivot.count++; &#125; // 从左边向中间推进直到遇到大于pivot的元素 while (left_index &lt; right_index &amp;&amp; data[left_index] &lt;= pivot.value) &#123; if (data[left_index] == pivot.value) &#123; pivot.count++; &#125; left_index++; &#125; // 将 左边大于pivot的元素 与 右边小于或等于pivot的元素 交换位置 swap_element(data, left_index, right_index); &#125; // Note：在排序过程中start_index位置的元素是不会变动位置的（其必然等于pivot）， // 而left_index位置的元素为最后一个小于或等于pivot的元素， // 这时交换二者位置后，便可确保pivot左边的元素均小于或等于pivot了 swap_element(data, start_index, left_index); pivot.index = left_index; return pivot;&#125;// 交换集合data中两个指定元素位置（index_0与index_1）的数据void swap_element(int data[], int index_0, int index_1) &#123; if (index_0 == index_1) &#123; return; &#125; int temp = data[index_0]; data[index_0] = data[index_1]; data[index_1] = temp;&#125;int compare_mode(Mode mode_0, Mode mode_1) &#123; return mode_0.count - mode_1.count;&#125; 这里主要强调以下几点： 在离调用最近的位置处声明变量，避免变量声明位置与第一次使用位置相隔太远 结构体数据的初始化采用(ANSI) C99方式以便于阅读，如，struct point p = { .y = yvalue, .x = xvalue };"},{"title":"记一次惊心动魄的CentOS系统升级经历","permalink":"https://flytreeleft.github.io/a-horrible-os-upgrading-for-centos/","text":"How to use yum history to roll back an update12345# List all update historiesyum history# Undo the specified transactionyum history undo &lt;transaction ID&gt; Fix ‘has missing requires of’12345678cp -a /var/lib/rpm /var/lib/rpm.bakcp -a /var/lib/yum /var/lib/yum.bakyum check \\ | grep \"has missing requires of\" \\ | awk '&#123;print $1&#125;' \\ | sed -E \"s/^[0-9]+://g\" \\ | while read p; do rpm -e --nodeps $p; done Fix ‘is a duplicate with’12345678910111213cp -a /var/lib/rpm /var/lib/rpm.bakcp -a /var/lib/yum /var/lib/yum.bakyum check \\ | grep \"is a duplicate with\" \\ | awk '&#123;print $1&#125;' \\ | sed -E \"s/^[0-9]+://g\" \\ | while read p; do rpm -e --justdb --nodeps $p; doneyum update# If 'yum update' still get some duplicated packages, just running the following commands## yum update | grep \"is a duplicate with\" | awk '&#123;print $1&#125;' | sed -E \"s/^[0-9]+://g\" | while read p; do rpm -e --justdb --nodeps $p; done## yum update"},{"title":"Nginx特例场景配置","permalink":"https://flytreeleft.github.io/the-special-case-configuration-of-nginx/","text":"本文所使用的相关代码片段可从 https://github.com/flytreeleft/docker-nginx-gateway 得到完整内容。 Nginx随机展示自定义错误页面 Source code: https://github.com/flytreeleft/docker-nginx-gateway/tree/master/config/error-pagesCustom error pages: https://github.com/flytreeleft/docker-nginx-gateway/tree/master/examples/epage.d/all 关键字： 随机展示多个错误页面 Nginx自定义错误页面 在访问HTTP站点时最容易出现的错误就是404，于是就有许多非常有个性的404错误页面。而为我们自己的站点放置一些简洁、清爽的错误页面，在资源再利用的前提下，也将为我们自身增加不少好感和亲和力。 这里将要介绍的便是如何为我们的站点配置自定义错误页面，并同时支持为相同错误随机展示不同的错误页面。 分类展示分类展示就是相同类型的错误使用同种风格的错误页面，这里简单分为404、40x（主要为400，401，403）、50x（主要为500，502，503，504），其配置内容如下： 1234567891011121314151617181920212223242526272829303132333435363738# Obmit the `[=[response]]` syntax to keep the error response code for clients.## http://nginx.org/en/docs/http/ngx_http_core_module.html#error_pageerror_page 404 /404/;error_page 400 401 403 /40x/;error_page 500 502 503 504 /50x/;location /404/ &#123; internal; random_index on; root /etc/nginx/epage.d;&#125;location /40x/ &#123; internal; random_index on; root /etc/nginx/epage.d; # Replace the placeholders in response content # for showing the corresponding status and message. sub_filter '&#123;&#123;status&#125;&#125;' '$status'; sub_filter '&#123;&#123;status_msg&#125;&#125;' '$status_msg'; sub_filter_once off;&#125;location /50x/ &#123; internal; random_index on; root /etc/nginx/epage.d; # Replace the placeholders in response content # for showing the corresponding status and message. sub_filter '&#123;&#123;status&#125;&#125;' '$status'; sub_filter '&#123;&#123;status_msg&#125;&#125;' '$status_msg'; sub_filter_once off;&#125; 这里将错误页面分别放置于/etc/nginx/epage.d/404/、/etc/nginx/epage.d/40x/、/etc/nginx/epage.d/50x/三个目录中，通过random_index指令可随机从这些目录中选择后缀为html的文件并返回给客户端，也就达到了错误页面随机展示的效果。注：1. internal指令限制了只能在Nginx内部请求该地址，外部访问将返回404错误；2. 若不需要随机展示的特性，在目录中始终放置一个HTML文件即可。 指令sub_filter用于过滤响应体中的特定字符串并替换为目标字符串。这里主要是替换{{status}}和{{status_msg}}（此为精确匹配，不能含其他字符）两个占位符以显示具体的错误码和错误信息，在错误页面中的合适位置引入这两个占位符即可。另外，$status_msg为与变量$status对应的状态信息，完整的映射关系见tmthrgd/nginx-status-text.conf。注：sub_filter_once off;为启用多次替换，确保页面中所有的占位符均被替换。 在引入该配置时需注意，该配置内容需添加到每个站点（即server {}）配置中，暂时不知道如何进行全局配置。为了方便可将以上内容放到单独的文件中（如，epage.conf）再通过include指令引入该配置。 统一展示统一展示就是所有错误都由相同页面展示，不同的只是显示的错误码和错误信息。以下为该方式的配置内容： 123456789101112131415161718# Obmit the `[=[response]]` syntax to keep the error response code for clients.## http://nginx.org/en/docs/http/ngx_http_core_module.html#error_pageerror_page 404 400 401 403 500 502 503 504 /_/;location /_/ &#123; internal; random_index on; # http://nginx.org/en/docs/http/ngx_http_core_module.html#alias # https://stackoverflow.com/questions/10631933/nginx-static-file-serving-confusion-with-root-alias#answer-10647080 alias /etc/nginx/epage.d/all/; # Replace the placeholders in response content # for showing the corresponding status and message. sub_filter '&#123;&#123;status&#125;&#125;' '$status'; sub_filter '&#123;&#123;status_msg&#125;&#125;' '$status_msg'; sub_filter_once off;&#125; 这里的配置内容和注意事项与分类展示的基本相同，所不同的是，错误页面被放置在/etc/nginx/epage.d/all/目录中，与分类展示的目录独立，从而可按需自由转换展示模式。 Nginx代理第三方http站点静态资源文件关键字： HTTPS反向代理HTTP静态资源 单页面Markdown编写与渲染方案 Nginx反向代理重定向拦截处理 这几天为部门搭建好了Maven仓库，为了便于指导部门同事能够准确配置并启用私有仓库，然后就打算写一份使用说明文档。 我不太喜欢写Word，也好几年几乎没用过了，一般都是直接写在部门的Wiki系统上。不过，一份简单的文档写到Wiki上又不太方便查阅，于是找了找可以在单个HTML里写Markdown并直接渲染展示的方案。 很快我就找到了Strapdown Zeta，其对Mardown的支持较为全面，并且使用很简单，还提供多套主题可自由切换。需要提到的是该库为Strapdown的衍生与改进版本，而Strapdown已经很长时间未更新了，选择Strapdown Zeta也是看重其活跃度。 在Strapdown Zeta的支持下仅需在&lt;xmp&gt;&lt;/xmp&gt;标签中编写Markdown并在最后引入 http://cdn.ztx.io/strapdown/strapdown.min.js 脚本即可。可惜的是，作者提供的该站点并未启用HTTPS，而我们在Let’s Encrypt的帮助下已经对部门的所有站点启用了HTTPS。这样，若在页面中引用非HTTPS资源，浏览器默认将阻止该资源的下载。 显然，这里不能直接在页面中引入该脚本，但是我也不愿再在站点上部署除使用文档之外的其他文件，就仅仅一个HTML文件即可，css什么的都不要有。 百般思索后，突然想到Internet Archive可以代理访问其他站点的页面，那我也可以专门为第三方静态资源搭建一个代理服务，该站点自身是HTTPS的，其在服务端获取到目标资源再返回给浏览器，这样该资源也就走的是HTTPS，既不用在服务器上存储这些资源，也可以自由代理其他第三方资源，而且不用管目标是不是HTTPS，甚至还可以代理一些无法访问到的资源。简单、经济、又实惠！:) 于是动手！这里假设代理站点为https://static.example.com，并构造代理链接为https://static.example.com/*/&lt;target url&gt;形式，这种结构可以方便Nginx做Location匹配，同时在使用和修改上均十分简单，我们不用改变目标资源的URL地址。 这里直接放出完整的配置：123456789101112131415161718192021222324252627282930313233343536373839server &#123; listen 443 ssl; listen [::]:443 ssl; server_name static.example.com; include /etc/nginx/vhost.d/static.example.com/01_ssl.conf; # https://static.example.com/*/http://others.com/asset.js -&gt; http://others.com/asset.js ## https://www.mediasuite.co.nz/blog/proxying-s3-downloads-nginx/ location ~* ^/\\*/(http[s]?):?/(.*?)/(.*)$ &#123; # Note: Remove the directive 'internal;' to accept the external requests, # otherwise it will return 404 for the external requests. # See http://nginx.org/en/docs/http/ngx_http_core_module.html#internal set $backend_protocol $1; set $backend_host $2; set $backend_path $3; set $backend_uri $backend_host/$backend_path$is_args$args; set $backend_url $backend_protocol://$backend_uri; # Headers for the remote server, unset Authorization and Cookie for security reasons. proxy_set_header Host $backend_host; proxy_set_header Authorization ''; proxy_set_header Cookie ''; # Stops the local disk from being written to (just forwards data through) proxy_max_temp_file_size 0; proxy_pass $backend_url; proxy_intercept_errors on; error_page 301 302 307 = @handle_backend_redirect; &#125; # Nginx Embedded Variables: http://nginx.org/en/docs/varindex.html location @handle_backend_redirect &#123; return 302 $scheme://$host/*/$upstream_http_location; &#125;&#125; 该配置参考的是Using NGINX’s X-Accel with Remote URLs。这里没有做特别的改动，主要是针对我们的实际需求做了些调整： 去掉了internal;指令，该指令是限制仅能在Nginx内部做该代理请求，而我们是需要外部直接获取到目标资源的，因此，需要去掉该指令，否则，外部访问时将始终为404； 针对目标URL地址存在重定向问题，在@handle_backend_redirect中，我又将重定向地址（其对应变量$upstream_http_location）再次进行代理，这样无论目标跳转多少次，代理站点均能获取到最终的返回内容，而不是在浏览器中又突然跳到另一个HTTP链接了； 最后提醒大家一点是，在网络中对安全要时刻保持警惕，尽可能降低敏感数据泄漏的风险，因此，这里切忌不要将客户端的Authorization和Cookie转发到目标站点了。 Nginx通过Squid穿透防火墙 Source code: https://github.com/flytreeleft/docker-nginx-gateway/blob/master/examples/vhost.d/static.example.com.conf 关键字： Nginx http_proxy：http_proxy为Linux中配置启用正向代理的环境变量，很多命令可识别该变量并通过所设定的代理地址请求目标资源 Nginx防火墙穿透 Nginx over Squid Squid behind Nginx Nginx bypass firewall via Squid 在前面提到，为了将HTTP请求转换为HTTPS请求，我专门搭建了个静态文件代理站点。刚开始访问还很正常，可后来便发现公司网关阻止了服务器对外部网站的访问，导致编写的文档无法渲染。 因此，我便考虑在Nginx服务端通过Squid（其他代理服务也可）再做一次代理以穿透公司的防火墙，确保静态资源的代理不再出现问题。 在多次尝试以及搜索网络资料后终于发现How to make an existing caching Nginx proxy use another proxy to bypass a firewall?所提到的实现方法。 在原配置的基础上综合改进后，得到新的配置内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455server &#123; listen 443 ssl; listen [::]:443 ssl; server_name static.example.com; include /etc/nginx/vhost.d/static.example.com/01_ssl.conf; # https://static.example.com/*/http://others.com/asset.js -&gt; http://others.com/asset.js ## https://www.mediasuite.co.nz/blog/proxying-s3-downloads-nginx/ location ~* ^/\\*/(http[s]?):?/(.*?)/(.*)$ &#123; # Note: Remove the directive 'internal;' to accept the external requests, # otherwise it will return 404 for the external requests. # See http://nginx.org/en/docs/http/ngx_http_core_module.html#internal set $backend_protocol $1; set $backend_host $2; set $backend_path $3; set $backend_uri $backend_host/$backend_path$is_args$args; set $backend_url $backend_protocol://$backend_uri; # Headers for the remote server, unset Authorization and Cookie for security reasons. proxy_set_header Host $backend_host; proxy_set_header Authorization ''; proxy_set_header Cookie ''; # Stops the local disk from being written to (just forwards data through) proxy_max_temp_file_size 0; # Forward the target to the squid proxy ## https://serverfault.com/questions/583743/how-to-make-an-existing-caching-nginx-proxy-use-another-proxy-to-bypass-a-firewa#683955 ## Hide the reponse header to protect the backend proxy ### http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_hide_header proxy_hide_header Via; proxy_hide_header X-Cache; proxy_hide_header X-Cache-Hits; proxy_hide_header X-Cache-Lookup; proxy_hide_header X-Fastly-Request-ID; proxy_hide_header X-Served-By; proxy_hide_header X-Timer; rewrite ^(.*)$ \"://$backend_uri\" break; rewrite ^(.*)$ \"$backend_protocol$1\" break; proxy_pass http://&lt;squid ip&gt;:3128; # Proxy to the target directly #proxy_pass $backend_url; proxy_intercept_errors on; error_page 301 302 307 = @handle_backend_redirect; &#125; # Nginx Embedded Variables: http://nginx.org/en/docs/varindex.html location @handle_backend_redirect &#123; return 302 $scheme://$host/*/$upstream_http_location; &#125;&#125; 这里需要特别注意的是： 这里做了两次rewrite是为了确保能够准确将目标URL地址附加到Squid的代理地址中以构成http://&lt;squid ip&gt;:3128/&lt;target url&gt;形式，同时，规避了因在rewrite的替换字符串中包含http://、https://或$scheme而导致重定向的问题； 同样为了安全考虑，这里隐藏了Squid的几个响应头，避免客户端得到Squid的真实IP地址而产生潜在的攻击风险； Nginx反向代理Nexus3的不同类型仓库关键字： Nginx反向代理 Nexus3不同类型仓库映射独立域名 Nexus3同时支持多种类型的资源存储，比如，Docker镜像、Maven依赖包、NPM等，不过，不同类型的资源访问方式和使用惯例是不一致的，因此，为每类资源提供符合惯例的仓库地址，再将请求转发到Nexus3仓库，对使用者而言将更加有好。 为此，本例针对Docker、Maven和NPM仓库分别给出Nginx的反向代理配置。 首先确定几个子站点的域名为如下形式： https://repo.example.com：Nexus3服务访问地址 https://mvn.example.com：Maven仓库访问地址 https://npm.example.com：NPM仓库地址 https://dcr.example.com：Docker镜像访问地址 https://repo.example.com的反向代理配置 Source code: https://github.com/flytreeleft/docker-nginx-gateway/blob/master/examples/vhost.d/repo.example.com.conf#L15 123456789101112131415server &#123; listen 443 ssl; listen [::]:443 ssl; server_name repo.example.com; include /etc/nginx/vhost.d/repo.example.com/01_ssl.conf; proxy_cache off; location / &#123; # Avoid to get address resolve error when starting set $nexus3 http://&lt;nexus3 ip&gt;:&lt;nexus3 web port&gt;; proxy_pass $nexus3; &#125;&#125; 对https://repo.example.com的配置很简单，直接将请求反向代理到Nexus3的Web接口即可。这里仅需要注意以下几点： 为了避免Nginx缓存导致资源的元数据（metadata）不能及时更新，所以，这里启用了proxy_cache off;以关闭代理缓存。当然，也可以根据实际情况仅对某些类的文件关闭缓存 Nginx在解析配置时会对proxy_pass的目标域名地址进行解析，若是解析失败则会导致Nginx启动异常，因此，这里采用变量方式将解析延迟到需要时，从而避免启动失败 https://mvn.example.com的反向代理配置 Source code: https://github.com/flytreeleft/docker-nginx-gateway/blob/master/examples/vhost.d/repo.example.com.conf#L110 需要科普一下的是，在Nexus3中访问某个仓库内的资源的URL结构为http://&lt;nexus3&gt;/#browse/browse/components:&lt;repo&gt;/，访问某个资源的URL结构为http://&lt;nexus3&gt;/repository/&lt;repo&gt;/&lt;asset path&gt;。其中，&lt;repo&gt;为仓库名称，所有类型的仓库均会有hosted（私有存储）、proxy（代理外部仓库）和group（组合同类仓库）三种模式。 为了规范内部和外部访问并便于进行权限控制（如，外部帐号不允许访问hosted中的源码等），这里创建了以下几个仓库： maven-hosted-releases：存储内部产品发布包。部署发布包时，向该仓库发送更新请求 maven-hosted-snapshots：存储内部产品开发快照包。部署快照包时，向该仓库发送更新请求 maven-hosted：maven-hosted-*的组合仓库。在Maven客户端更新依赖时，从该仓库下载内部产品的发布包或快照包 maven-&lt;3rd repo url&gt;：对第三方仓库的代理仓库，&lt;3rd repo url&gt;为站点域名，比如，maven-apache.org。也可以按其他规范命名，只要能友好区分不同仓库即可 maven-public：所有maven-&lt;3rd repo url&gt;的组合仓库。用于统一下载第三方的依赖包 然后，我们期望在访问以下URL链接时，能够将请求转发到对应的资源上： GET https://mvn.example.com/public/&lt;asset&gt; -&gt; https://repo.example.com/repository/maven-public/&lt;asset&gt; GET https://mvn.example.com/hosted/&lt;asset&gt; -&gt; https://repo.example.com/repository/maven-hosted/&lt;asset&gt; GET https://mvn.example.com/releases/&lt;asset&gt; -&gt; https://repo.example.com/repository/maven-hosted/&lt;asset&gt; GET https://mvn.example.com/snapshots/&lt;asset&gt; -&gt; https://repo.example.com/repository/maven-hosted/&lt;asset&gt; POST https://mvn.example.com/releases/&lt;asset&gt; -&gt; https://repo.example.com/repository/maven-hosted-releases/&lt;asset&gt; POST https://mvn.example.com/snapshots/&lt;asset&gt; -&gt; https://repo.example.com/repository/maven-hosted-snapshots/&lt;asset&gt; 根据以上规范和需求，https://mvn.example.com的最终配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445server &#123; listen 443 ssl; listen [::]:443 ssl; server_name mvn.example.com; include /etc/nginx/vhost.d/mvn.example.com/01_ssl.conf; # Redirect to the maven repository (named as 'maven-public') of Nexus3 location = / &#123; return 302 $scheme://repo.example.com/#browse/browse/components:maven-public/; &#125; # Redirect to the target asset of Nexus3 location ~* ^/repository/maven-.+$ &#123; return 301 $scheme://repo.example.com$request_uri; &#125; # Disable cache of assets proxy_cache off; proxy_read_timeout 300; proxy_connect_timeout 300; location / &#123; set $nexus3 http://&lt;nexus3 ip&gt;:&lt;nexus3 web port&gt;; # NOTE: rewrite and proxy_pass should be put in the same block ## http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite # web browse or `mvn compile` if ($request_method ~* \"^GET|HEAD$\") &#123; rewrite ^/public/(.*) /repository/maven-public/$1 break; rewrite ^/hosted/(.*) /repository/maven-hosted/$1 break; rewrite ^/releases/(.*) /repository/maven-hosted/$1 break; rewrite ^/snapshots/(.*) /repository/maven-hosted/$1 break; proxy_pass $nexus3; break; &#125; # `mvn deploy` if ($request_method ~* \"^POST|PUT$\") &#123; rewrite ^/(releases|snapshots)/(.*) /repository/maven-hosted-$1/$2 break; proxy_pass $nexus3; break; &#125; &#125;&#125; 这里需要注意以下几点： 在前两个location匹配后均跳转到https://repo.example.com，因为，这两个地址的请求可认为只能是从浏览器发出的，直接跳转到Nexus3可让访问者了解我们使用的是Nexus3系统，从而尽快熟悉该系统，完全没有必要将Nexus3代理到https://mvn.example.com域名下 return 301代表固定跳转，浏览器后续访问相同URL时将直接跳转到指定的目标，而不会再向服务器发送请求；而return 302为临时跳转，浏览器的后续访问依然会向服务器发送请求。对= /做临时跳转是因为我们可能会在该URL下放些说明文档之类的页面，如果做固定跳转，那么若后续支持该需求则只能在客户端清空浏览器Cookie后方能生效，对使用者会造成一定困扰 看过Maven代码可以发现其使用的HttpClient库向仓库发送HTTP请求，所以，只需要对$request_method做匹配，将读请求转发到maven-pulic和maven-hosted两个组合仓库中，而将写请求转发到maven-hosted-*仓库即可 剩下的就是调整Maven settings.xml。对普通的仅做依赖下载更新的配置为（仅列出主要内容，请按实际需求修改）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- https://maven.apache.org/settings.html --&gt;&lt;settings&gt; &lt;servers&gt; &lt;server&gt; &lt;!-- Associated with &lt;repository/&gt; and &lt;pluginRepository/&gt; --&gt; &lt;id&gt;your-repo-public&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;your-repo-hosted&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;your-repo&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;your-repo-public&lt;/id&gt; &lt;url&gt;https://mvn.example.com/public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;your-repo-hosted&lt;/id&gt; &lt;url&gt;https://mvn.example.com/hosted/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;your-repo-public&lt;/id&gt; &lt;url&gt;https://mvn.example.com/public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;your-repo&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 而对需要向仓库部署包的配置则为（仅列出主要内容，请按实际需求修改）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!-- https://maven.apache.org/settings.html --&gt;&lt;settings&gt; &lt;servers&gt; &lt;server&gt; &lt;!-- Associated with &lt;repository/&gt; and &lt;pluginRepository/&gt; --&gt; &lt;id&gt;public&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;username&gt;&lt;/username&gt; &lt;password&gt;&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;your-repo&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;url&gt;https://mvn.example.com/public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;https://mvn.example.com/releases/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;https://mvn.example.com/snapshots/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;thirdparty&lt;/id&gt; &lt;url&gt;https://mvn.example.com/thirdparty/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;url&gt;https://mvn.example.com/public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;your-repo&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 注意，Maven在更新时是按照settings.xml中定义的仓库顺序依次查找依赖直到内置的central仓库，若在某个仓库中找到依赖则停止查找。因此，需要注意调整仓库的位置以避免因依赖同名而导致下载的内容与预期的不同。 https://npm.example.com的反向代理配置 Source code: https://github.com/flytreeleft/docker-nginx-gateway/blob/master/examples/vhost.d/repo.example.com.conf#L182 https://npm.example.com与https://mvn.example.com的规划和注意事项基本一致，只是npm-hosted仓库直接使用hosted模式，因为NPM依赖包没有快照版本，而npm-public仓库依然为group模式，用于组合多个第三方仓库。 以下为对https://npm.example.com的完整配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243server &#123; listen 443 ssl; listen [::]:443 ssl; server_name npm.example.com; include /etc/nginx/vhost.d/npm.example.com/01_ssl.conf; # Redirect to the npm repository (named as 'npm-public') of Nexus3 location = / &#123; return 302 $scheme://repo.example.com/#browse/browse/components:npm-public/; &#125; # Redirect to the target asset of Nexus3 location ~* ^/repository/npm-.+$ &#123; return 301 $scheme://repo.example.com$request_uri; &#125; # Disable cache of assets proxy_cache off; proxy_read_timeout 60; proxy_connect_timeout 60; location / &#123; set $nexus3 http://&lt;nexus3 ip&gt;:&lt;nexus3 web port&gt;; # NOTE: rewrite and proxy_pass should be put in the same block ## http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite # web browse or `npm install` if ($request_method ~* \"^GET$\") &#123; rewrite ^/(.+) /repository/npm-public/$1 break; proxy_pass $nexus3; break; &#125; # `npm publish` if ($request_method ~* \"^PUT|DELETE$\") &#123; rewrite ^/(.+) /repository/npm-hosted/$1 break; proxy_pass $nexus3; break; &#125; &#125;&#125; 在安装或发布模块时可通过选项--registry临时指定目标仓库地址： 安装模块：npm --registry=https://npm.example.com install &lt;module&gt; 发布模块：npm --registry=https://npm.example.com publish &lt;folder&gt; 也可以替换默认仓库，直接使用私有仓库：npm config set registry https://npm.example.com。 若需要还原为默认仓库，则运行命令npm config set registry https://registry.npmjs.org。 登录仓库则执行命令npm login --registry=https://npm.example.com。 https://dcr.example.com的反向代理配置 Source code: https://github.com/flytreeleft/docker-nginx-gateway/blob/master/examples/vhost.d/repo.example.com.conf#L50 在Nexus3中，Docker类型的仓库需要使用不同的端口进行访问，创建仓库时需要为仓库自行设定一个HTTP端口号，然后再通过Nginx将读写请求转发到不同的端口上。 这里创建一个hosted模式的仓库docker-hosted用于docker push镜像，创建一个group模式的仓库docker-public用于组合多个第三方镜像仓库。 最终，针对https://dcr.example.com的Nginx配置如下： 12345678910111213141516171819202122232425262728293031323334353637server &#123; listen 443 ssl; listen [::]:443 ssl; server_name dcr.example.com; include /etc/nginx/vhost.d/dcr.example.com/01_ssl.conf; # Disable cache of assets proxy_cache off; proxy_read_timeout 600; proxy_connect_timeout 600; location / &#123; if ($http_user_agent !~* \"^docker/.+$\") &#123; return 301 $scheme://repo.example.com/#browse/browse/components:docker-public$request_uri; &#125; set $nexus3 http://&lt;nexus3 ip&gt;; # docker pull dcr.example.com/xx-xx set $repo_url $nexus3:&lt;docker-public port&gt;; # https://github.com/moby/moby/blob/7061b0f748c29ffd1e6852cdc5dd11f90840eb1c/daemon/logger/awslogs/cloudwatchlogs_test.go#L71 # https://github.com/moby/moby/blob/master/client/image_pull.go # https://github.com/moby/moby/blob/master/client/image_push.go # NOTE: rewrite and proxy_pass should be put in the same block ## http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite # docker push dcr.example.com/xx-xx if ($request_method ~* \"^HEAD|POST|PUT|DELETE|PATCH$\") &#123; set $repo_url $nexus3:&lt;docker-hosted port&gt;; &#125; proxy_pass $repo_url; &#125;&#125; 这里同样需注意以下几个问题： Docker发送的HTTP请求中User Agent包含docker字符串，因此，如果$http_user_agent中没有这个字符串，则视为浏览器访问，直接跳转到https://repo.example.com 从Docker的源码中可以发现HTTP Method为HEAD、POST、PUT、DELETE、PATCH均与镜像变更（新增、删除、打标签、更新等）有关，因此，需要将这些请求均转发到docker-hosted仓库 在使用时可分别通过以下命令登录仓库以及拉取或推送镜像： 登录仓库：docker login dcr.example.com 拉取镜像：docker pull dcr.example.com/&lt;image name&gt;:&lt;image version&gt; 推送镜像：docker push dcr.example.com/&lt;image name&gt;:&lt;image version&gt;"},{"title":"未来社会形态畅想","permalink":"https://flytreeleft.github.io/the-future-social-formation/","text":"The post isn’t finished yet, it will be updated anytime! 无现金社会提要： 比特币、比特交易网络 以太坊 IOTA 如何找回IOTA余额：可以从中了解转账机制与流程 自由工作提要： 为个人价值体现、兴趣、探索未知而工作，而不是为了生活和生存 社会基础能够保障个人衣食无忧，确保个人在任何时刻都无需担心温饱和居住问题，从而有精力专注于思考和探索上 种植、生产、制造、输送流程实现全自动化、机械化 自由选择工作时间、工作地点，不为特定的个人、团体、组织、企业工作，仅为达到某个目标而做事并获得对等回报 万物互联提要： 联网的每个设备既为内容消费端，也是内容存储端，同时也是网络热点，附近的设备可随时且自由地连接在一起 基于内容进行网络访问，而不再基于IP或域名，任何端点都可能含有所需内容，就近选择并从该端点下载内容即可，内容原始发布端将无关紧要 分布式、无中心化的基础网络，不再需要路由器、交换机、服务器等中心设备 初始阶段需要通过ISP打通各个闭环网络（闭环的连接设备群组），当多个闭环网络连接形成足够大的闭环后，设备之间的通信将无需ISP的支持 家用路由器等可自由共享网络，助推「万物网」的形成"},{"title":"作恶行为清单","permalink":"https://flytreeleft.github.io/the-evil-behaviors/","text":"列举日常和网络中所发现的软件、应用、服务等的「作恶」行为，将其永久钉在「耻辱柱」上。有条件的或有候选方案的，应主动弃用之！坚持开放、坚持自由。点击下载自由软件自由社会.pdf就事论事，不针对个人、企业、平台，挖掘现象本质，努力尝试寻找更优方案 为逼迫用户使用客户端而阉割Web端的基本功能 案例： 闲鱼Web端隐藏搜索框 来源： https://www.appinn.com/xianyu-search-box/ 评语： 若欲达KPI，必先「中二自宫」 封闭平台之间因为利益互怼，以用户为筹码逼迫对方作出让步 案例： 谷歌Youtube禁止亚马逊Echo访问 来源： http://www.ifanr.com/951314 相关： 360与QQ大战、菜鸟与顺丰互怼 评语： 用户在我手，天下跟我走。看不惯？你咬我呀！ 观点： 在「封闭平台」中，用户从一开始便是平台的筹码，当平台「自认为」利益受到其他平台威胁时，便会不惜以损害用户体验的方式进行反击，其平日讨好用户的伪善面目便暴露无疑。平台越大，心眼越小，不安全感越严重，思路越单一，解决问题的方式越是直接粗暴。"},{"title":"软件开发最佳实践","permalink":"https://flytreeleft.github.io/the-better-software-development-practice/","text":"The post isn’t finished yet, it will be updated anytime!"},{"title":"软件开发行为准则","permalink":"https://flytreeleft.github.io/the-software-development-criterion/","text":"The post isn’t finished yet, it will be updated anytime! 谨慎对待用户隐私提要： 不是仅用户确认后的数据才算是「用户隐私」，任何与用户相关的数据都应该「默认」视为用户隐私，不需要任何形式的确认，而只有经过用户确认和同意的数据方可用作其他用途，且前提必须是明确告知数据为何要做次用途，以及将被如何利用、涉及哪些风险等 努力降低总体开发和使用成本提要： 总体成本等于所有个人的时间成本与财力物力之总和 提供到达/完成目标的最短操作路径 提供详细的文档（开发、设计、使用），备注相关知识来源链接，从最终使用者角度考虑使用流程、会遇到的困难和疑问、期望的快捷方式 将当前关注点在一页（一屏）中展示；直接到达操作按钮； 从开发者与最终用户的角度思考各个关注点，直接提供所需信息、接口、说明以及软件功能 不是一眼就明了其意义的图标需提供文字提示或说明，或者直接使用文字"},{"title":"如何突破自己的瓶颈？","permalink":"https://flytreeleft.github.io/how-to-break-out-of-your-limit/","text":"The post isn’t finished yet, it will be updated anytime! 以旁观者角度审视自己提要： 勇敢面对自己，正视自己的缺点 客观分析自己的好的、坏的甚至是邪恶的想法，不好的想法切不可影响到他人，需要自我消化 人无完人，对于非理性情绪不要过分压抑，在不影响他人的情况下采取各种积极或消极的方式去释放这些情绪 消极的释放方式所要达到的目的是推翻重建，进入全新的境界，从而从另一个视角看待原来的情绪和行为 理性看待他人的评论、观点和建议，保持就事论事的态度，切忌带有个人情绪，更不要被别人带着走（影响个人情绪、怀疑个人价值观等等）提要： 若无法静心并保持客观，那就禁用评论，不与人争论，专注于自己的思考方向，但需多接触不同观点，及时调整，不可过于执念 开放心态，放下恩怨是非，求同存异 事物的美好在于不同，不同的观点、思想的碰撞才能产生激烈的火花，而消灭差异最终只会沦为「行尸走肉」 「尊重你说话的权利，但也保留我的个人意见」 没有绝对的对错，对错都是相对的，在不同身份、不同环境、不同角度甚至可能发生反转。依据当前已知信息作出相对合理的选择，并在实践过程中不断调整 专注于探索自己的生活方式和方向，不羡慕别人的生活，先过好自己的提要： 时常在朋友圈、新闻、他人口中看到或听到某某光鲜亮丽、幸福美满、事业猛进，而自己依然处于迷茫、混沌、一人吃饱全家不饿的状态，心里倍感失落、感觉就是一loser，进而嫉妒别人，甚而诅咒他人 那你需要静下来分析，如何形成当前局面，自己真正需要的是什么，自己在生活的路上做了什么 别人都在幸福的路上忙碌奔波，而你却有如此闲心去妒嫉别人的生活？ 人人都有自己的活法，也有不同的满足，找到属于自己的，并聚焦于此，为此而忙碌，心无杂念 以“出世”的态度去观察他人和自己，不要觉得自己过得不如意就希望全世界都得与你一起面对种种不如意，从他人的不幸中去寻找优越感，将会使自己越来越失败、愤恨、怀疑自己。不断战胜、超越自己才是正途 始终保持内心的平静，避免外界对自己的诱惑和干扰，要有自己的坚守，纯粹的名与利终究是带不走的 沉下心来专注于自己的事情，朝着自己认为可行的方向前行，也许会失败，但在行进过程中同样也能学到很多东西，所以，不要一开始就因为害怕失败而不去做，先勇敢地去做，快速尝试以快速失败或成功 对所见、所听、所接触的事、物、人，取其精华去其糟泊，吸收有用可取的方式，探索本质，获得处事之道提要： 有些人就是人生路上的“小怪兽”，有些人是良师益友 随时准备两件事情，以避免当前事情完成后不知道该继续做什么的困境准备一份阅读书籍列表，在无所事事时，避免无目的的刷网页，转而看书会更加有益"},{"title":"Git使用案例","permalink":"https://flytreeleft.github.io/git-usage-cases/","text":"拆分子目录到新仓库场景通常为便于项目开发和调试，开发前期会将多个组件放在同一仓库中，而当各个组件的功能结构和代码逐渐区域稳定后，便需要将其拆分出来进行独立开发和管理，以便于与其他项目共享组件。 此时，不仅需要将组件所在目录内的代码全部拆分到单独的仓库，同时，还需要确保历史记录能够完整保留。 操作1234567891011121314151617# Clone the repository that contains the subfolder.git clone https://github.com/USERNAME/REPOSITORY-NAMEcd REPOSITORY-NAME# To filter out the subfolder from the rest of the files in the repository## FOLDER-NAME: The folder within your project that you'd like to create a separate repository from.## BRANCH-NAME: The default branch for your current project, for example, 'master' or 'gh-pages'git filter-branch --prune-empty --subdirectory-filter FOLDER-NAME BRANCH-NAME# Change the existing remote 'origin' (or other name) URL to the new repository URLgit remote set-url origin https://github.com/USERNAME/NEW-REPOSITORY-NAME.git# [Optional] Change BRANCH-NAME to the default branch (e.g. 'master') of the new repositorygit branch -m BRANCH-NAME master# Push your changes to the new repositorygit push -u origin master 注意： 在第二步操作后，当前目录将会只剩下子目录中的文件 最好在新的目录中进行上述操作：可以直接clone，也可以从复制已有项目到其他目录 参考 Splitting a subfolder out into a new repository 修改变更提交人的信息场景基于项目长远发展考虑，将某个具有实用价值且吸引力极大的项目开源，需要将项目从公司内部仓库开放到Github上，但相关开发人员在两个系统中所用帐号不一致，为了便于issue交流以及PR提交，这时，需要更改历史中的提交人信息。 其实，大多数时候，很可能是要弃用内部仓库并将工作全部移到公共仓库时才有这么做的需求，其余情况并不需要这么做。 操作 部分替换： 12345678910git filter-branch --commit-filter \\ 'if [ \"$GIT_AUTHOR_NAME\" = \"OldAuthor Name\" ]; then \\ export GIT_AUTHOR_NAME=\"Author Name\"; \\ export GIT_AUTHOR_EMAIL=authorEmail@example.com; \\ export GIT_COMMITTER_NAME=\"Commmiter Name\"; \\ export GIT_COMMITTER_EMAIL=commiterEmail@example.com; \\ fi; \\ git commit-tree \"$@\" '# Push to the branch 'master' of the existing repositorygit push --force origin master 全部替换： 12345678git filter-branch --commit-filter \\ 'export GIT_AUTHOR_NAME=\"Author Name\"; \\ export GIT_AUTHOR_EMAIL=authorEmail@example.com; \\ export GIT_COMMITTER_NAME=\"Commmiter Name\"; \\ export GIT_COMMITTER_EMAIL=commiterEmail@example.com; \\ git commit-tree \"$@\" '# Push to the branch 'master' of the existing repositorygit push --force origin master 注意： 若出现类似Cannot create a new backup. A previous backup already exists in refs/original/. Force overwriting the backup with -f的异常提示，则需要在filter-branch命令中添加选项-f，即git filter-branch -f，以强制进行修改 如果提交的分支是受保护的，则在提交时会出现remote: GitLab: You are not allowed to force push code to a protected branch on this project.的错误信息，此时，需要调整仓库设置，临时取消对目标分支的保护 参考 Could I change my name and surname in all previous commits? 迁移子分支至新仓库场景某个项目仓库中可能存在多个功能特性（features）分支，在一段时候后，基于产品功能规划和开发维护等方面的考虑，需要将某些特性分支独立成新的项目或子项目，将其迁移到新的仓库中。 操作12345678# Push 'feature-branch' to the branch 'master' (or others) of new repositorygit push url://to/new/repository.git feature-branch:master# [Optional] Delete the 'feature-branch' from current repositorygit branch -d feature-branch# Clone codes from new repositorygit clone url://to/new/repository.git feature-branch 参考 How do I move a Git branch out into its own repository? 修改历史提交备注信息场景在拆分子目录和迁移子分支两个场景中，在新仓库中的历史提交记录的备注信息可能存在与项目不相关的信息或者包含原始项目中的一些敏感内容。这个时候，就可能需要修改这些备注信息。 当然，也可能是因为发现以前的提交备注中包含错别字或者表达不清晰，为了避免对其他人产生误导或困惑，将提交的备注信息予以纠正也是很有必要的。 操作 获取提交ID并Rebase到该提交 12345# List histories and get the commit id which should be modifiedgit log# Rebase to 3 commits before the specified commit (e.g. 'ce0ac37c83')git rebase --interactive ce0ac37c83~3 将提交所在行开始处的pick修改为edit 提交并应用修改 123456789# New commit messagegit commit --amend -m \"fix that the dragging preview can not be shown\"# Apply the changes and return to HEADgit rebase --continue# Push to the branch 'master' of the existing repository## Make sure that the remote branch 'master' is unprotectedgit push --force origin master 注意： 如果需要放弃修改，则运行命令git rebase --abort 若直接rebase到目标commit，则该提交不会显示在可修改清单内，故，需选择从其之前的第N个（e.g. ~3）提交开始 若提交至非空的仓库，需确保目标分支不是受保护（protected）的 在应用修改后，git将从修改位置开始重新构建commit tree，因此，从该位置开始到HEAD的commit id均会发生变化，但原始commit tree依然存在，通过git diff ce0ac37c83等可看到该提交的变更情况 参考 How to modify existing, unpushed commits?"},{"title":"Hello world!","permalink":"https://flytreeleft.github.io/hello-world/","text":"1System.out.println(\"Hello world!\"); 1alert('Hello world!'); 1echo \"Hello world!\""}]}