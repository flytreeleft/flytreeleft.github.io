<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM内存分析：数据库连接池耗尽"><meta name="keywords" content="连接池耗尽,Connection pool exhausted"><meta name="author" content="flytreeleft,flytreeleft@126.com"><meta name="copyright" content="flytreeleft"><title>JVM内存分析：数据库连接池耗尽 | flytreeleft's Blog</title><link rel="shortcut icon" href="/assets/profile/favicon.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#提要"><span class="toc-number">1.</span> <span class="toc-text">提要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#案例分析"><span class="toc-number">2.</span> <span class="toc-text">案例分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决方案"><span class="toc-number">3.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/assets/profile/avatar.jpg"></div><div class="author-info__name text-center">flytreeleft</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">29</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">10</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://coolshell.cn/" target="_blank">酷壳</a><a class="author-info-links__name text-center" href="https://www.infoq.com/" target="_blank">InfoQ</a><a class="author-info-links__name text-center" href="http://www.yinwang.org/" target="_blank">当然我在扯淡</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/assets/profile/walle-watch-the-stars-sky.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">flytreeleft's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/quotes">Quotes</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">JVM内存分析：数据库连接池耗尽</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JVM内存分析/">JVM内存分析</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1,813</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>由于数据库连接十分耗时，采取<strong>即需即连</strong>的方式会导致应用响应缓慢，因此，在Java应用中均采用<strong>数据库连接池</strong>统一维护一定数量的<code>Connection</code>对象，连接池中的<code>Connection</code>均保持与数据库的长连接，这样，该连接将随时可用，从而提高应用响应和处理速度。</p>
<p>但是，在普遍的使用不当的情形中，最多的问题便是没有及时<code>释放连接</code>，这里的释放是指将<code>Connection</code>对象归还连接池。若连接未被释放，则连接池将被很快耗尽（Exhausted），从而无法提供新的连接，最终导致应用不能进行数据库操作，并在尝试获取新的连接时出现以下异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Caused by: org.hibernate.exception.GenericJDBCException: Could not open connection</span><br><span class="line">    at org.hibernate.exception.internal.StandardSQLExceptionConverter.convert(StandardSQLExceptionConverter.java:<span class="number">54</span>)</span><br><span class="line">    at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:<span class="number">125</span>)</span><br><span class="line">    at org.hibernate.engine.jdbc.spi.SqlExceptionHelper.convert(SqlExceptionHelper.java:<span class="number">110</span>)</span><br><span class="line">    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:<span class="number">221</span>)</span><br><span class="line">    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.getConnection(LogicalConnectionImpl.java:<span class="number">157</span>)</span><br><span class="line">    at org.hibernate.internal.SessionImpl.connection(SessionImpl.java:<span class="number">550</span>)</span><br><span class="line">    at org.springframework.orm.hibernate4.HibernateTransactionManager.doBegin(HibernateTransactionManager.java:<span class="number">426</span>)</span><br><span class="line">    ... <span class="number">9</span> more</span><br><span class="line">Caused by: org.apache.commons.dbcp.SQLNestedException: Cannot get a connection, pool error Timeout waiting <span class="keyword">for</span> idle object</span><br><span class="line">    at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:<span class="number">114</span>)</span><br><span class="line">    at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:<span class="number">1044</span>)</span><br><span class="line">    at org.hibernate.service.jdbc.connections.internal.DatasourceConnectionProviderImpl.getConnection(DatasourceConnectionProviderImpl.java:<span class="number">141</span>)</span><br><span class="line">    at org.hibernate.internal.AbstractSessionImpl$NonContextualJdbcConnectionAccess.obtainConnection(AbstractSessionImpl.java:<span class="number">292</span>)</span><br><span class="line">    at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.obtainConnection(LogicalConnectionImpl.java:<span class="number">214</span>)</span><br><span class="line">    ... <span class="number">12</span> more</span><br><span class="line">Caused by: java.util.NoSuchElementException: Timeout waiting <span class="keyword">for</span> idle object</span><br><span class="line">    at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:<span class="number">1174</span>)</span><br><span class="line">    at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:<span class="number">106</span>)</span><br><span class="line">    ... <span class="number">16</span> more</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><blockquote>
<p>有关JVM内存转储方式的说明见<a href="/the-jvm-dump-analyse-for-tomcat-memory-leak/">JVM内存分析：Tomcat内存泄漏</a>。</p>
</blockquote>
<p>在本案例应用（约定称为「应用A」）的使用过程中偶尔会在前端弹出<code>Timeout waiting for idle object</code>的异常提示框。经过查看完整的异常堆栈（看上面）可发现，异常发生在从连接池获取<code>Connection</code>时，在对<a href="https://github.com/apache/commons-pool/blob/POOL_1_6/src/java/org/apache/commons/pool/impl/GenericObjectPool.java#L1174" target="_blank" rel="noopener">GenericObjectPool</a>源码分析后可初步确定是因为连接池已满而无法分配新的<code>Connection</code>造成的。</p>
<p>为进一步确认该问题，将应用A的内存转储（<code>sudo -u tomcat jmap -dump:format=b,file=heap-dump.bin &lt;java_pid&gt;</code>）并通过<a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">Eclipse Memory Analyzer - MAT</a>对其内存进行分析。</p>
<p>点击工具栏中的<code>OQL</code>图标，这里需要通过<a href="https://www.ibm.com/developerworks/library/j-memoryanalyzer/#N103C9" target="_blank" rel="noopener">OQL</a>进行一些复杂的过滤查询（OQL：<code>SELECT OBJECTS ds FROM org.apache.commons.dbcp.BasicDataSource ds</code>）：</p>
<p><img src="/assets/images/jvm-dump/connection-pool-exhausted/java-memory-leak-oql-instanceof-basicdatasource-in-heap-dump.png" alt></p>
<blockquote>
<ul>
<li>OQL的语法可从MAT的<code>Help -&gt; Help Contents</code>菜单中进入帮助手册查询到；</li>
<li><code>org.apache.commons.dbcp.BasicDataSource</code>为应用中使用的<code>DataSource</code>的实现类，其内部引用<code>org.apache.commons.dbcp.PoolingDataSource</code>，并在<code>PoolingDataSource</code>中负责从连接池申请新的连接；</li>
</ul>
</blockquote>
<p>从图中可以看到，连接池<code>org.apache.commons.pool.impl.GenericObjectPool</code>的<code>_numActive</code>为<span style="color: red;">749</span>，而在应用中为其分配的最大活跃连接数（<code>maxActive</code>）为<code>750</code>。因此，可以进一步确定连接池的确已达到分配上限，在并发情况下将不会再分配更多连接，从而导致等待超时并抛出异常。</p>
<p>再看看内存中是否存在未被释放的MySQL连接。</p>
<p>由于MAT默认不分析<code>unreachable</code>对象，所以，在开始前需通过其自带的工具<code>ParseHeapDump.sh</code>（或<code>ParseHeapDump.bat</code>）<a href="https://wiki.eclipse.org/MemoryAnalyzer/FAQ#How_to_analyse_unreachable_objects" target="_blank" rel="noopener">分析不可达对象</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行该命令前需删除dump文件所在目录中由MAT生成的分析文件</span></span><br><span class="line">$ ParseHeapDump.sh -keep_unreachable_objects heap-dump.bin</span><br></pre></td></tr></table></figure>
<p>点击MAT的菜单<code>File -&gt; Open Heap Dump</code>选择文件<code>heap-dump.bin</code>载入转储分析文件，然后，通过OQL（<code>SELECT cn, cn.isClosed, cn.io.mysqlConnection, cn.io.mysqlConnection.closed FROM INSTANCEOF com.mysql.jdbc.JDBC4Connection cn</code>）得到MySQL Connection对象如下：</p>
<p><img src="/assets/images/jvm-dump/connection-pool-exhausted/java-memory-leak-oql-instanceof-mysql-connection-in-heap-dump.png" alt></p>
<blockquote>
<p>点击工具栏中的分组图标可按照Class Loader对结果进行分组；<br>在MySQL驱动中的<code>Connection</code>所引用的相关对象为：</p>
<ul>
<li>com.mysql.jdbc.JDBC4Connection#io:com.mysql.jdbc.MysqlIO</li>
<li>com.mysql.jdbc.MysqlIO#mysqlConnection:java.net.Socket</li>
<li>java.net.Socket#closed:boolean</li>
</ul>
</blockquote>
<p>可以发现，在36个连接中仅有2个是正常关闭的，其余的<code>Connection</code>未被关闭，但对应的<code>Socket</code>连接却处于关闭状态。这里可以假设出以下两种可能的情形：</p>
<ul>
<li><code>Connection</code>在<strong>使用时</strong>出现网络中断，导致<code>Socket</code>非正常关闭；</li>
<li><code>Connection</code>在<strong>使用后</strong>未被正常关闭，并且在某个时刻发生了<code>Socket</code>连接中断；</li>
</ul>
<p>对于第一种情形，<code>Socket</code>的异常关闭势必会抛出异常，并最终在使用方拦截到该异常并关闭<code>Connection</code>，而这里的<code>Connection</code>为非关闭状态，说明使用方并未准确做资源的释放处理。第二种情形，自然也是因为资源未被及时释放了。</p>
<p>因此，<code>Connection</code>没有被及时、准确地释放是相当肯定的事情了。</p>
<p>但这里依然有个疑问，为啥连接池里记录分配的连接为<code>749</code>，而实际查到的<code>Connection</code>对象只有30多个，其余的哪儿去了？</p>
<p>针对上述问题，限于基本功的问题，目前还没有确切的定论，但大致可推断是MySQL驱动中的<code>com.mysql.jdbc.AbandonedConnectionCleanupThread</code>对弱引用的<code>com.mysql.jdbc.JDBC4Connection</code>对象做了资源<code>主动回收</code>处理：</p>
<p><img src="/assets/images/jvm-dump/connection-pool-exhausted/mysql-source-abandoned-connection-cleanup.png" alt></p>
<p><code>com.mysql.jdbc.NonRegisteringDriver.ConnectionPhantomReference</code>为虚引用类<code>java.lang.ref.PhantomReference</code>的扩展类，其将在<code>java.lang.ref.Reference.ReferenceHandler#run</code>中等待JVM启动GC时进行清理活动。</p>
<blockquote>
<p>Java引用相关的知识可阅读<a href="https://benjaminwhx.com/2018/05/19/%E5%A4%A7%E8%AF%9DJava%E4%B8%AD%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">详解java.lang.ref包中的4种引用</a>。</p>
</blockquote>
<p>既然得到了看似很有道理的分析结论，那就应该有方法复现当前的问题。</p>
<p>首先，通过IDE工具查找应用中主动获取<code>Connection</code>对象而未释放的代码位置，最终找出以下几处：</p>
<ul>
<li>xx/xx/xx/XxQueryImpl.java @r74605: L357, L1607</li>
<li>…</li>
</ul>
<p>经过调用分析后，可找到以下几个相关的Web API以用于复现验证：</p>
<ul>
<li>/a/xx/queryXx.mvc</li>
<li>/a/xx/countXx.mvc</li>
<li>…</li>
</ul>
<p>需要注意的是，一般MySQL服务端会限定并发连接数，为了快速复现当前问题，可通过以下语句调整MySQL的默认最大连接数（重启后将失效）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看默认配置： show variables like '%connect%';</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections = <span class="number">850</span>;</span><br></pre></td></tr></table></figure>
<p>在登录应用A后，在浏览器控制台中执行以下代码便可复现最开始提到的异常问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="string">'/a'</span>;</span><br><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">    ctx + <span class="string">'/xx/queryXx.mvc'</span>,</span><br><span class="line">    ctx + <span class="string">'/xx/countXx.mvc'</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> waitTime = <span class="number">0.1</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRequest</span>(<span class="params">urls, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!urls || urls.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = index || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> url = urls[<span class="number">0</span>];</span><br><span class="line">    $.ajax(&#123;<span class="attr">url</span>: url, <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i, url, <span class="built_in">arguments</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            doRequest(urls.slice(<span class="number">1</span>), i + <span class="number">1</span>);</span><br><span class="line">        &#125;, waitTime);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestCount = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">var</span> requestURLs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; requestCount / urls.length; i++) &#123;</span><br><span class="line">    requestURLs = requestURLs.concat(urls);</span><br><span class="line">&#125;</span><br><span class="line">doRequest(requestURLs);</span><br></pre></td></tr></table></figure>
<p><img src="/assets/images/jvm-dump/connection-pool-exhausted/app-a-reproduct-timeout-wait-for-idle-object.png" alt></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>找到了根本原因，解决方案就很简单了：</p>
<ul>
<li>在<code>try {...} finally {...}</code>语句的<code>finally</code>块中关闭<strong>主动获取</strong>的<code>Connection</code>对象。</li>
</ul>
<p>而本案例中的业务需求似乎比较特殊，具体方案需根据实际业务需求确定，但必须坚持以下原则：</p>
<ul>
<li>在<code>finally</code>块中释放主动获取的<code>Connection</code>对象；</li>
<li>数据库类型无关：尽可能避免在代码中根据数据库类型做条件判断，首选<a href="http://docs.jboss.org/hibernate/core/3.5/reference/en-US/html_single/#queryhql" target="_blank" rel="noopener">HQL</a>所支持的<u>数据库无关</u>的查询语句和表达式</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">Eclipse Memory Analyzer - MAT</a></li>
<li><a href="https://blogs.oracle.com/sundararajan/querying-java-heap-with-oql" target="_blank" rel="noopener">Querying Java heap with OQL</a></li>
<li><a href="https://www.ibm.com/developerworks/library/j-memoryanalyzer/#N103C9" target="_blank" rel="noopener">OQL</a></li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:flytreeleft@126.com">flytreeleft</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://flytreeleft.github.io/the-jvm-dump-analyse-for-connection-pool-exhausted/">https://flytreeleft.github.io/the-jvm-dump-analyse-for-connection-pool-exhausted/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">知识共享署名 4.0 国际许可协议</a> 许可协议。转载请注明来自 <a href="https://flytreeleft.github.io" target="_blank">flytreeleft's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/连接池耗尽/">连接池耗尽</a><a class="post-meta__tags" href="/tags/Connection-pool-exhausted/">Connection pool exhausted</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/assets/profile/wechatpay.png"><div class="post-qr-code__desc"></div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/assets/profile/alipay.png"><div class="post-qr-code__desc"></div></div></div></article><nav id="pagination"><div class="prev-post pull-left"><a href="/the-jvm-dump-analyse-for-where-is-the-memory/"><i class="fa fa-chevron-left">  </i><span>JVM内存分析：内存都去哪儿了</span></a></div><div class="next-post pull-right"><a href="/the-jvm-dump-analyse-for-tomcat-memory-leak/"><span>JVM内存分析：Tomcat内存泄漏</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By flytreeleft</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu/js/anti-baidu-latest.min.js"></script><script src="/js/utils.js?version=1.3"></script><script src="/js/fancybox.js?version=1.3"></script><script src="/js/sidebar.js?version=1.3"></script><script src="/js/copy.js?version=1.3"></script><script src="/js/fireworks.js?version=1.3"></script><script src="/js/transition.js?version=1.3"></script><script src="/js/scroll.js?version=1.3"></script><script src="/js/head.js?version=1.3"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>